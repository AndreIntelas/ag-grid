var q=Object.defineProperty,z=Object.getOwnPropertyDescriptor,u=(t,e,o,i)=>{for(var r=i>1?void 0:i?z(e,o):e,s=t.length-1,n;s>=0;s--)(n=t[s])&&(r=(i?n(e,o,r):n(r))||r);return i&&r&&q(e,o,r),r};import{ModuleNames as Z}from"@ag-grid-community/core";import{_ as S,Autowired as A,Bean as ee,BeanStub as te,ChangedPath as oe,Events as f,Optional as O,PostConstruct as ie,ClientSideRowModelSteps as d,RowNode as Y,RowHighlightPosition as I}from"@ag-grid-community/core";import{Events as j,RowNode as re,_ as T}from"@ag-grid-community/core";var L=class y{constructor(e,o,i,r,s,n){this.nextId=0,this.rowCountReady=!1,this.allNodesMap={},this.rootNode=e,this.gridOptionsService=o,this.eventService=i,this.columnModel=r,this.beans=n,this.selectionService=s,this.rootNode.group=!0,this.rootNode.level=-1,this.rootNode.id=y.ROOT_NODE_ID,this.rootNode.allLeafChildren=[],this.rootNode.childrenAfterGroup=[],this.rootNode.childrenAfterSort=[],this.rootNode.childrenAfterAggFilter=[],this.rootNode.childrenAfterFilter=[]}getCopyOfNodesMap(){return T.cloneObject(this.allNodesMap)}getRowNode(e){return this.allNodesMap[e]}setRowData(e){if(typeof e=="string"){console.warn("AG Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first");return}this.rowCountReady=!0,this.dispatchRowDataUpdateStartedEvent(e);const o=this.rootNode,i=this.rootNode.sibling;o.childrenAfterFilter=null,o.childrenAfterGroup=null,o.childrenAfterAggFilter=null,o.childrenAfterSort=null,o.childrenMapped=null,o.updateHasChildren(),this.nextId=0,this.allNodesMap={},e?o.allLeafChildren=e.map(r=>this.createNode(r,this.rootNode,y.TOP_LEVEL)):(o.allLeafChildren=[],o.childrenAfterGroup=[]),i&&(i.childrenAfterFilter=o.childrenAfterFilter,i.childrenAfterGroup=o.childrenAfterGroup,i.childrenAfterAggFilter=o.childrenAfterAggFilter,i.childrenAfterSort=o.childrenAfterSort,i.childrenMapped=o.childrenMapped,i.allLeafChildren=o.allLeafChildren)}updateRowData(e,o){this.rowCountReady=!0,this.dispatchRowDataUpdateStartedEvent(e.add);const i={remove:[],update:[],add:[]},r=[];return this.executeRemove(e,i,r),this.executeUpdate(e,i,r),this.executeAdd(e,i),this.updateSelection(r,"rowDataChanged"),o&&T.sortRowNodesByOrder(this.rootNode.allLeafChildren,o),i}isRowCountReady(){return this.rowCountReady}dispatchRowDataUpdateStartedEvent(e){const o={type:j.EVENT_ROW_DATA_UPDATE_STARTED,firstRowData:e?.length?e[0]:null};this.eventService.dispatchEvent(o)}updateSelection(e,o){const i=e.length>0;if(i&&this.selectionService.setNodesSelected({newValue:!1,nodes:e,suppressFinishActions:!0,source:o}),this.selectionService.updateGroupsFromChildrenSelections(o),i){const r={type:j.EVENT_SELECTION_CHANGED,source:o};this.eventService.dispatchEvent(r)}}executeAdd(e,o){var i;const{add:r,addIndex:s}=e;if(T.missingOrEmpty(r))return;const n=r.map(a=>this.createNode(a,this.rootNode,y.TOP_LEVEL));if(typeof s=="number"&&s>=0){const{allLeafChildren:a}=this.rootNode,p=a.length;let h=s;if(this.gridOptionsService.get("treeData")&&s>0&&p>0){for(let R=0;R<p;R++)if(((i=a[R])==null?void 0:i.rowIndex)==s-1){h=R+1;break}}const c=a.slice(0,h),l=a.slice(h,a.length);this.rootNode.allLeafChildren=[...c,...n,...l]}else this.rootNode.allLeafChildren=[...this.rootNode.allLeafChildren,...n];this.rootNode.sibling&&(this.rootNode.sibling.allLeafChildren=this.rootNode.allLeafChildren),o.add=n}executeRemove(e,o,i){const{remove:r}=e;if(T.missingOrEmpty(r))return;const s={};r.forEach(n=>{const a=this.lookupRowNode(n);a&&(a.isSelected()&&i.push(a),a.clearRowTopAndRowIndex(),s[a.id]=!0,delete this.allNodesMap[a.id],o.remove.push(a))}),this.rootNode.allLeafChildren=this.rootNode.allLeafChildren.filter(n=>!s[n.id]),this.rootNode.sibling&&(this.rootNode.sibling.allLeafChildren=this.rootNode.allLeafChildren)}executeUpdate(e,o,i){const{update:r}=e;T.missingOrEmpty(r)||r.forEach(s=>{const n=this.lookupRowNode(s);n&&(n.updateData(s),!n.selectable&&n.isSelected()&&i.push(n),this.setMasterForRow(n,s,y.TOP_LEVEL,!1),o.update.push(n))})}lookupRowNode(e){const o=this.gridOptionsService.getCallback("getRowId");let i;if(o){const r=o({data:e,level:0});if(i=this.allNodesMap[r],!i)return console.error(`AG Grid: could not find row id=${r}, data item was not found for this id`),null}else if(i=this.rootNode.allLeafChildren.find(r=>r.data===e),!i)return console.error("AG Grid: could not find data item as object was not found",e),console.error("Consider using getRowId to help the Grid find matching row data"),null;return i||null}createNode(e,o,i){const r=new re(this.beans);r.group=!1,this.setMasterForRow(r,e,i,!0);const s=this.gridOptionsService.get("suppressParentsInRowNodes");return o&&!s&&(r.parent=o),r.level=i,r.setDataAndId(e,this.nextId.toString()),this.allNodesMap[r.id]&&console.warn(`AG Grid: duplicate node id '${r.id}' detected from getRowId callback, this could cause issues in your grid.`),this.allNodesMap[r.id]=r,this.nextId++,r}setMasterForRow(e,o,i,r){if(this.gridOptionsService.get("treeData"))e.setMaster(!1),r&&(e.expanded=!1);else{if(this.gridOptionsService.get("masterDetail")){const a=this.gridOptionsService.get("isRowMaster");a?e.setMaster(a(o)):e.setMaster(!0)}else e.setMaster(!1);if(r){const a=this.columnModel.getRowGroupColumns(),p=a?a.length:0,h=i+p;e.expanded=e.master?this.isExpanded(h):!1}}}isExpanded(e){const o=this.gridOptionsService.get("groupDefaultExpanded");return o===-1?!0:e<o}};L.TOP_LEVEL=0,L.ROOT_NODE_ID="ROOT_NODE_ID";var se=L,w=class extends te{constructor(){super(...arguments),this.onRowHeightChanged_debounced=S.debounce(this.onRowHeightChanged.bind(this),100),this.rowsToDisplay=[],this.hasStarted=!1,this.shouldSkipSettingDataOnStart=!1,this.isRefreshingModel=!1,this.rowCountReady=!1}init(){const t=this.refreshModel.bind(this,{step:d.EVERYTHING}),e=!this.gridOptionsService.get("suppressAnimationFrame"),o=this.refreshModel.bind(this,{step:d.EVERYTHING,afterColumnsChanged:!0,keepRenderedRows:!0,animate:e});this.addManagedListener(this.eventService,f.EVENT_NEW_COLUMNS_LOADED,o),this.addManagedListener(this.eventService,f.EVENT_COLUMN_ROW_GROUP_CHANGED,t),this.addManagedListener(this.eventService,f.EVENT_COLUMN_VALUE_CHANGED,this.onValueChanged.bind(this)),this.addManagedListener(this.eventService,f.EVENT_COLUMN_PIVOT_CHANGED,this.refreshModel.bind(this,{step:d.PIVOT})),this.addManagedListener(this.eventService,f.EVENT_FILTER_CHANGED,this.onFilterChanged.bind(this)),this.addManagedListener(this.eventService,f.EVENT_SORT_CHANGED,this.onSortChanged.bind(this)),this.addManagedListener(this.eventService,f.EVENT_COLUMN_PIVOT_MODE_CHANGED,t),this.addManagedListener(this.eventService,f.EVENT_GRID_STYLES_CHANGED,this.onGridStylesChanges.bind(this)),this.addManagedListener(this.eventService,f.EVENT_GRID_READY,()=>this.onGridReady()),this.addPropertyListeners(),this.rootNode=new Y(this.beans),this.nodeManager=new se(this.rootNode,this.gridOptionsService,this.eventService,this.columnModel,this.selectionService,this.beans)}addPropertyListeners(){const t=new Set(["treeData","masterDetail"]),e=new Set(["suppressParentsInRowNodes","groupDefaultExpanded","groupAllowUnbalanced","initialGroupOrderComparator","groupHideOpenParents","groupDisplayType"]),o=new Set(["excludeChildrenWhenTreeDataFiltering"]),i=new Set(["removePivotHeaderRowWhenSingleValueColumn","pivotRowTotals","pivotColumnGroupTotals","suppressExpandablePivotGroups"]),r=new Set(["getGroupRowAgg","alwaysAggregateAtRootLevel","groupIncludeTotalFooter","suppressAggFilteredOnly"]),s=new Set(["postSortRows","groupDisplayType","accentedSort"]),n=new Set([]),a=new Set(["groupRemoveSingleChildren","groupRemoveLowestSingleChildren","groupIncludeFooter"]),p=[...t,...e,...o,...i,...i,...r,...s,...n,...a];this.addManagedPropertyListeners(p,h=>{var g;const c=(g=h.changeSet)==null?void 0:g.properties;if(!c)return;const l=R=>c.some(v=>R.has(v));if(l(t)){this.setRowData(this.rootNode.allLeafChildren.map(R=>R.data));return}if(l(e)){this.refreshModel({step:d.EVERYTHING});return}if(l(o)){this.refreshModel({step:d.FILTER});return}if(l(i)){this.refreshModel({step:d.PIVOT});return}if(l(r)){this.refreshModel({step:d.AGGREGATE});return}if(l(s)){this.refreshModel({step:d.SORT});return}if(l(n)){this.refreshModel({step:d.FILTER_AGGREGATES});return}l(a)&&this.refreshModel({step:d.MAP})}),this.addManagedPropertyListener("rowHeight",()=>this.resetRowHeights())}start(){this.hasStarted=!0,this.shouldSkipSettingDataOnStart?this.dispatchUpdateEventsAndRefresh():this.setInitialData()}setInitialData(){const t=this.gridOptionsService.get("rowData");t&&(this.shouldSkipSettingDataOnStart=!0,this.setRowData(t))}ensureRowHeightsValid(t,e,o,i){let r,s=!1;do{r=!1;const n=this.getRowIndexAtPixel(t),a=this.getRowIndexAtPixel(e),p=Math.max(n,o),h=Math.min(a,i);for(let g=p;g<=h;g++){const c=this.getRow(g);if(c.rowHeightEstimated){const l=this.gridOptionsService.getRowHeightForNode(c);c.setRowHeight(l.height),r=!0,s=!0}}r&&this.setRowTopAndRowIndex()}while(r);return s}setRowTopAndRowIndex(){const t=this.environment.getDefaultRowHeight();let e=0;const o=new Set,i=this.gridOptionsService.isDomLayout("normal");for(let r=0;r<this.rowsToDisplay.length;r++){const s=this.rowsToDisplay[r];if(s.id!=null&&o.add(s.id),s.rowHeight==null){const n=this.gridOptionsService.getRowHeightForNode(s,i,t);s.setRowHeight(n.height,n.estimated)}s.setRowTop(e),s.setRowIndex(r),e+=s.rowHeight}return o}clearRowTopAndRowIndex(t,e){const o=t.isActive(),i=s=>{s&&s.id!=null&&!e.has(s.id)&&s.clearRowTopAndRowIndex()},r=s=>{if(i(s),i(s.detailNode),i(s.sibling),s.hasChildren()&&s.childrenAfterGroup){const n=s.level==-1;o&&!n&&!s.expanded||s.childrenAfterGroup.forEach(r)}};r(this.rootNode)}ensureRowsAtPixel(t,e,o=0){const i=this.getRowIndexAtPixel(e),r=this.getRow(i),s=!this.gridOptionsService.get("suppressAnimationFrame");return r===t[0]?!1:(t.forEach(n=>{S.removeFromArray(this.rootNode.allLeafChildren,n)}),t.forEach((n,a)=>{S.insertIntoArray(this.rootNode.allLeafChildren,n,Math.max(i+o,0)+a)}),this.refreshModel({step:d.EVERYTHING,keepRenderedRows:!0,keepEditingRows:!0,animate:s}),!0)}highlightRowAtPixel(t,e){const o=e!=null?this.getRowIndexAtPixel(e):null,i=o!=null?this.getRow(o):null;if(!i||!t||i===t||e==null){this.lastHighlightedRow&&(this.lastHighlightedRow.setHighlighted(null),this.lastHighlightedRow=null);return}const r=this.getHighlightPosition(e,i);this.lastHighlightedRow&&this.lastHighlightedRow!==i&&(this.lastHighlightedRow.setHighlighted(null),this.lastHighlightedRow=null),i.setHighlighted(r),this.lastHighlightedRow=i}getHighlightPosition(t,e){if(!e){const r=this.getRowIndexAtPixel(t);if(e=this.getRow(r||0),!e)return I.Below}const{rowTop:o,rowHeight:i}=e;return t-o<i/2?I.Above:I.Below}getLastHighlightedRowNode(){return this.lastHighlightedRow}isLastRowIndexKnown(){return!0}getRowCount(){return this.rowsToDisplay?this.rowsToDisplay.length:0}getTopLevelRowCount(){if(this.rowsToDisplay&&this.rowsToDisplay[0]===this.rootNode)return 1;const e=this.rootNode.childrenAfterAggFilter;return e?e.length:0}getTopLevelRowDisplayedIndex(t){if(this.rowsToDisplay&&this.rowsToDisplay[0]===this.rootNode)return t;let o=this.rootNode.childrenAfterSort[t];if(this.gridOptionsService.get("groupHideOpenParents"))for(;o.expanded&&o.childrenAfterSort&&o.childrenAfterSort.length>0;)o=o.childrenAfterSort[0];return o.rowIndex}getRowBounds(t){if(S.missing(this.rowsToDisplay))return null;const e=this.rowsToDisplay[t];return e?{rowTop:e.rowTop,rowHeight:e.rowHeight}:null}onRowGroupOpened(){const t=this.gridOptionsService.isAnimateRows();this.refreshModel({step:d.MAP,keepRenderedRows:!0,animate:t})}onFilterChanged(t){if(t.afterDataChange)return;const e=this.gridOptionsService.isAnimateRows(),i=t.columns.length===0||t.columns.some(r=>r.isPrimary())?d.FILTER:d.FILTER_AGGREGATES;this.refreshModel({step:i,keepRenderedRows:!0,animate:e})}onSortChanged(){const t=this.gridOptionsService.isAnimateRows();this.refreshModel({step:d.SORT,keepRenderedRows:!0,animate:t,keepEditingRows:!0})}getType(){return"clientSide"}onValueChanged(){this.columnModel.isPivotActive()?this.refreshModel({step:d.PIVOT}):this.refreshModel({step:d.AGGREGATE})}createChangePath(t){const e=S.missingOrEmpty(t),o=new oe(!1,this.rootNode);return(e||this.gridOptionsService.get("treeData"))&&o.setInactive(),o}isSuppressModelUpdateAfterUpdateTransaction(t){if(!this.gridOptionsService.get("suppressModelUpdateAfterUpdateTransaction")||t.rowNodeTransactions==null)return!1;const e=t.rowNodeTransactions.filter(i=>i.add!=null&&i.add.length>0||i.remove!=null&&i.remove.length>0);return e==null||e.length==0}buildRefreshModelParams(t){let e=d.EVERYTHING;const o={everything:d.EVERYTHING,group:d.EVERYTHING,filter:d.FILTER,map:d.MAP,aggregate:d.AGGREGATE,sort:d.SORT,pivot:d.PIVOT};if(S.exists(t)&&(e=o[t]),S.missing(e)){console.error(`AG Grid: invalid step ${t}, available steps are ${Object.keys(o).join(", ")}`);return}const i=!this.gridOptionsService.get("suppressAnimationFrame");return{step:e,keepRenderedRows:!0,keepEditingRows:!0,animate:i}}refreshModel(t){if(!this.hasStarted||this.isRefreshingModel||this.columnModel.shouldRowModelIgnoreRefresh())return;let e=typeof t=="object"&&"step"in t?t:this.buildRefreshModelParams(t);if(!e||this.isSuppressModelUpdateAfterUpdateTransaction(e))return;const o=this.createChangePath(e.rowNodeTransactions);switch(this.isRefreshingModel=!0,e.step){case d.EVERYTHING:this.doRowGrouping(e.rowNodeTransactions,e.rowNodeOrder,o,!!e.afterColumnsChanged);case d.FILTER:this.doFilter(o);case d.PIVOT:this.doPivot(o);case d.AGGREGATE:this.doAggregate(o);case d.FILTER_AGGREGATES:this.doFilterAggregates(o);case d.SORT:this.doSort(e.rowNodeTransactions,o);case d.MAP:this.doRowsToDisplay()}const i=this.setRowTopAndRowIndex();this.clearRowTopAndRowIndex(o,i),this.isRefreshingModel=!1;const r={type:f.EVENT_MODEL_UPDATED,animate:e.animate,keepRenderedRows:e.keepRenderedRows,newData:e.newData,newPage:!1,keepUndoRedoStack:e.keepUndoRedoStack};this.eventService.dispatchEvent(r)}isEmpty(){const t=S.missing(this.rootNode.allLeafChildren)||this.rootNode.allLeafChildren.length===0;return S.missing(this.rootNode)||t||!this.columnModel.isReady()}isRowsToRender(){return S.exists(this.rowsToDisplay)&&this.rowsToDisplay.length>0}getNodesInRangeForSelection(t,e){let o=!e,i=!1;const r=[],s=this.gridOptionsService.get("groupSelectsChildren");return this.forEachNodeAfterFilterAndSort(n=>{if(i)return;if(o&&(n===e||n===t)&&(i=!0,n.group&&s)){r.push(...n.allLeafChildren);return}if(!o){if(n!==e&&n!==t)return;o=!0}if(!n.group||!s){r.push(n);return}}),r}setDatasource(t){console.error("AG Grid: should never call setDatasource on clientSideRowController")}getTopLevelNodes(){return this.rootNode?this.rootNode.childrenAfterGroup:null}getRootNode(){return this.rootNode}getRow(t){return this.rowsToDisplay[t]}isRowPresent(t){return this.rowsToDisplay.indexOf(t)>=0}getRowIndexAtPixel(t){if(this.isEmpty()||this.rowsToDisplay.length===0)return-1;let e=0,o=this.rowsToDisplay.length-1;if(t<=0)return 0;if(S.last(this.rowsToDisplay).rowTop<=t)return this.rowsToDisplay.length-1;let r=-1,s=-1;for(;;){const n=Math.floor((e+o)/2),a=this.rowsToDisplay[n];if(this.isRowInPixel(a,t)||(a.rowTop<t?e=n+1:a.rowTop>t&&(o=n-1),r===e&&s===o))return n;r=e,s=o}}isRowInPixel(t,e){const o=t.rowTop,i=t.rowTop+t.rowHeight;return o<=e&&i>e}forEachLeafNode(t){this.rootNode.allLeafChildren&&this.rootNode.allLeafChildren.forEach((e,o)=>t(e,o))}forEachNode(t,e=!1){this.recursivelyWalkNodesAndCallback({nodes:[...this.rootNode.childrenAfterGroup||[]],callback:t,recursionType:0,index:0,includeFooterNodes:e})}forEachNodeAfterFilter(t,e=!1){this.recursivelyWalkNodesAndCallback({nodes:[...this.rootNode.childrenAfterAggFilter||[]],callback:t,recursionType:1,index:0,includeFooterNodes:e})}forEachNodeAfterFilterAndSort(t,e=!1){this.recursivelyWalkNodesAndCallback({nodes:[...this.rootNode.childrenAfterSort||[]],callback:t,recursionType:2,index:0,includeFooterNodes:e})}forEachPivotNode(t,e=!1){this.recursivelyWalkNodesAndCallback({nodes:[this.rootNode],callback:t,recursionType:3,index:0,includeFooterNodes:e})}recursivelyWalkNodesAndCallback(t){var e;const{nodes:o,callback:i,recursionType:r,includeFooterNodes:s}=t;let{index:n}=t;for(let h=0;h<o.length;h++){const g=o[h];if(i(g,n++),g.hasChildren()&&!g.footer){let c=null;switch(r){case 0:c=g.childrenAfterGroup;break;case 1:c=g.childrenAfterAggFilter;break;case 2:c=g.childrenAfterSort;break;case 3:c=g.leafGroup?null:g.childrenAfterSort;break}c&&(n=this.recursivelyWalkNodesAndCallback({nodes:[...c],callback:i,recursionType:r,index:n,includeFooterNodes:s}))}}const a=(e=o[0])==null?void 0:e.parent;if(!s||!a)return n;if(a===this.rootNode){if(!this.gridOptionsService.get("groupIncludeTotalFooter"))return n}else if(!this.gridOptionsService.getGroupIncludeFooter()({node:a}))return n;return a.createFooter(),i(a.sibling,n++),n}doAggregate(t){this.aggregationStage&&this.aggregationStage.execute({rowNode:this.rootNode,changedPath:t})}doFilterAggregates(t){this.filterAggregatesStage?this.filterAggregatesStage.execute({rowNode:this.rootNode,changedPath:t}):this.rootNode.childrenAfterAggFilter=this.rootNode.childrenAfterFilter}expandOrCollapseAll(t){const e=this.gridOptionsService.get("treeData"),o=this.columnModel.isPivotActive(),i=n=>{n&&n.forEach(a=>{const p=()=>{a.expanded=t,i(a.childrenAfterGroup)};if(e){S.exists(a.childrenAfterGroup)&&p();return}if(o){!a.leafGroup&&p();return}a.group&&p()})};this.rootNode&&i(this.rootNode.childrenAfterGroup),this.refreshModel({step:d.MAP});const r=t?"expandAll":"collapseAll",s={type:f.EVENT_EXPAND_COLLAPSE_ALL,source:r};this.eventService.dispatchEvent(s)}doSort(t,e){this.sortStage.execute({rowNode:this.rootNode,rowNodeTransactions:t,changedPath:e})}doRowGrouping(t,e,o,i){if(this.groupStage){if(t?this.groupStage.execute({rowNode:this.rootNode,rowNodeTransactions:t,rowNodeOrder:e,changedPath:o}):this.groupStage.execute({rowNode:this.rootNode,changedPath:o,afterColumnsChanged:i}),this.gridOptionsService.get("groupSelectsChildren")&&this.selectionService.updateGroupsFromChildrenSelections("rowGroupChanged",o)){const s={type:f.EVENT_SELECTION_CHANGED,source:"rowGroupChanged"};this.eventService.dispatchEvent(s)}}else this.rootNode.childrenAfterGroup=this.rootNode.allLeafChildren,this.rootNode.sibling&&(this.rootNode.sibling.childrenAfterGroup=this.rootNode.childrenAfterGroup),this.rootNode.updateHasChildren();this.nodeManager.isRowCountReady()&&(this.rowCountReady=!0,this.eventService.dispatchEventOnce({type:f.EVENT_ROW_COUNT_READY}))}doFilter(t){this.filterStage.execute({rowNode:this.rootNode,changedPath:t})}doPivot(t){this.pivotStage&&this.pivotStage.execute({rowNode:this.rootNode,changedPath:t})}getCopyOfNodesMap(){return this.nodeManager.getCopyOfNodesMap()}getRowNode(t){if(typeof t=="string"&&t.indexOf(Y.ID_PREFIX_ROW_GROUP)==0){let o;return this.forEachNode(i=>{i.id===t&&(o=i)}),o}return this.nodeManager.getRowNode(t)}setRowData(t){this.selectionService.reset("rowDataChanged"),this.nodeManager.setRowData(t),this.hasStarted&&this.dispatchUpdateEventsAndRefresh()}dispatchUpdateEventsAndRefresh(){const t={type:f.EVENT_ROW_DATA_UPDATED};this.eventService.dispatchEvent(t),this.refreshModel({step:d.EVERYTHING,newData:!0})}batchUpdateRowData(t,e){if(this.applyAsyncTransactionsTimeout==null){this.rowDataTransactionBatch=[];const o=this.gridOptionsService.getAsyncTransactionWaitMillis();this.applyAsyncTransactionsTimeout=window.setTimeout(()=>{this.executeBatchUpdateRowData()},o)}this.rowDataTransactionBatch.push({rowDataTransaction:t,callback:e})}flushAsyncTransactions(){this.applyAsyncTransactionsTimeout!=null&&(clearTimeout(this.applyAsyncTransactionsTimeout),this.executeBatchUpdateRowData())}executeBatchUpdateRowData(){this.valueCache.onDataChanged();const t=[],e=[];let o=!1;if(this.rowDataTransactionBatch&&this.rowDataTransactionBatch.forEach(i=>{const r=this.nodeManager.updateRowData(i.rowDataTransaction,void 0);e.push(r),i.callback&&t.push(i.callback.bind(null,r)),typeof i.rowDataTransaction.addIndex=="number"&&(o=!0)}),this.commonUpdateRowData(e,void 0,o),t.length>0&&window.setTimeout(()=>{t.forEach(i=>i())},0),e.length>0){const i={type:f.EVENT_ASYNC_TRANSACTIONS_FLUSHED,results:e};this.eventService.dispatchEvent(i)}this.rowDataTransactionBatch=null,this.applyAsyncTransactionsTimeout=void 0}updateRowData(t,e){this.valueCache.onDataChanged();const o=this.nodeManager.updateRowData(t,e),i=typeof t.addIndex=="number";return this.commonUpdateRowData([o],e,i),o}createRowNodeOrder(){if(this.gridOptionsService.get("suppressMaintainUnsortedOrder"))return;const e={};if(this.rootNode&&this.rootNode.allLeafChildren)for(let o=0;o<this.rootNode.allLeafChildren.length;o++){const i=this.rootNode.allLeafChildren[o];e[i.id]=o}return e}commonUpdateRowData(t,e,o){if(!this.hasStarted)return;const i=!this.gridOptionsService.get("suppressAnimationFrame");o&&(e=this.createRowNodeOrder());const r={type:f.EVENT_ROW_DATA_UPDATED};this.eventService.dispatchEvent(r),this.refreshModel({step:d.EVERYTHING,rowNodeTransactions:t,rowNodeOrder:e,keepRenderedRows:!0,keepEditingRows:!0,animate:i})}doRowsToDisplay(){this.rowsToDisplay=this.flattenStage.execute({rowNode:this.rootNode})}onRowHeightChanged(){this.refreshModel({step:d.MAP,keepRenderedRows:!0,keepEditingRows:!0,keepUndoRedoStack:!0})}onRowHeightChangedDebounced(){this.onRowHeightChanged_debounced()}resetRowHeights(){const t=this.resetRowHeightsForAllRowNodes();this.rootNode.setRowHeight(this.rootNode.rowHeight,!0),this.rootNode.sibling&&this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight,!0),t&&this.onRowHeightChanged()}resetRowHeightsForAllRowNodes(){let t=!1;return this.forEachNode(e=>{e.setRowHeight(e.rowHeight,!0);const o=e.detailNode;o&&o.setRowHeight(o.rowHeight,!0),e.sibling&&e.sibling.setRowHeight(e.sibling.rowHeight,!0),t=!0}),t}onGridStylesChanges(){this.columnModel.isAutoRowHeightActive()||this.resetRowHeights()}onGridReady(){this.hasStarted||this.setInitialData()}isRowDataLoaded(){return this.rowCountReady}};u([A("columnModel")],w.prototype,"columnModel",2),u([A("selectionService")],w.prototype,"selectionService",2),u([A("filterManager")],w.prototype,"filterManager",2),u([A("valueCache")],w.prototype,"valueCache",2),u([A("beans")],w.prototype,"beans",2),u([A("filterStage")],w.prototype,"filterStage",2),u([A("sortStage")],w.prototype,"sortStage",2),u([A("flattenStage")],w.prototype,"flattenStage",2),u([O("groupStage")],w.prototype,"groupStage",2),u([O("aggregationStage")],w.prototype,"aggregationStage",2),u([O("pivotStage")],w.prototype,"pivotStage",2),u([O("filterAggregatesStage")],w.prototype,"filterAggregatesStage",2),u([ie],w.prototype,"init",1),w=u([ee("rowModel")],w);import{Autowired as ne,Bean as ae,BeanStub as le}from"@ag-grid-community/core";var M=class extends le{execute(t){const{changedPath:e}=t;this.filterService.filter(e)}};u([ne("filterService")],M.prototype,"filterService",2),M=u([ae("filterStage")],M);import{_ as $,Autowired as J,Bean as de,BeanStub as he}from"@ag-grid-community/core";var N=class extends he{execute(t){const e=this.sortController.getSortOptions(),o=$.exists(e)&&e.length>0,i=o&&$.exists(t.rowNodeTransactions)&&this.gridOptionsService.get("deltaSort"),r=e.some(s=>this.gridOptionsService.isColumnsSortingCoupledToGroup()?s.column.isPrimary()&&s.column.isRowGroupActive():!!s.column.getColDef().showRowGroup);this.sortService.sort(e,o,i,t.rowNodeTransactions,t.changedPath,r)}};u([J("sortService")],N.prototype,"sortService",2),u([J("sortController")],N.prototype,"sortController",2),N=u([de("sortStage")],N);import{_ as H,Autowired as K,Bean as ce,BeanStub as ue,RowNode as pe}from"@ag-grid-community/core";var E=class extends ue{execute(t){const e=t.rowNode,o=[],i=this.columnModel.isPivotMode(),r=i&&e.leafGroup,s=r?[e]:e.childrenAfterSort,n=this.getFlattenDetails();this.recursivelyAddToRowsToDisplay(n,s,o,i,0);const a=o.length>0;return!r&&a&&n.groupIncludeTotalFooter&&(e.createFooter(),this.addRowNodeToRowsToDisplay(n,e.sibling,o,0)),o}getFlattenDetails(){const t=this.gridOptionsService.get("groupRemoveSingleChildren");return{groupRemoveLowestSingleChildren:!t&&this.gridOptionsService.get("groupRemoveLowestSingleChildren"),groupRemoveSingleChildren:t,isGroupMultiAutoColumn:this.gridOptionsService.isGroupMultiAutoColumn(),hideOpenParents:this.gridOptionsService.get("groupHideOpenParents"),groupIncludeTotalFooter:this.gridOptionsService.get("groupIncludeTotalFooter"),getGroupIncludeFooter:this.gridOptionsService.getGroupIncludeFooter()}}recursivelyAddToRowsToDisplay(t,e,o,i,r){if(!H.missingOrEmpty(e))for(let s=0;s<e.length;s++){const n=e[s],a=n.hasChildren(),p=i&&!a,h=t.groupRemoveSingleChildren&&a&&n.childrenAfterGroup.length===1,g=t.groupRemoveLowestSingleChildren&&a&&n.leafGroup&&n.childrenAfterGroup.length===1,c=i&&n.leafGroup,l=t.hideOpenParents&&n.expanded&&!n.master&&!c;if(!p&&!l&&!h&&!g&&this.addRowNodeToRowsToDisplay(t,n,o,r),!(i&&n.leafGroup)){if(a){const v=h||g;if(n.expanded||v){const F=v?r:r+1;this.recursivelyAddToRowsToDisplay(t,n.childrenAfterSort,o,i,F),t.getGroupIncludeFooter({node:n})?(n.createFooter(),this.addRowNodeToRowsToDisplay(t,n.sibling,o,F)):n.destroyFooter()}}else if(n.master&&n.expanded){const v=this.createDetailNode(n);this.addRowNodeToRowsToDisplay(t,v,o,r)}}}}addRowNodeToRowsToDisplay(t,e,o,i){o.push(e),e.setUiLevel(t.isGroupMultiAutoColumn?0:i)}createDetailNode(t){if(H.exists(t.detailNode))return t.detailNode;const e=new pe(this.beans);return e.detail=!0,e.selectable=!1,e.parent=t,H.exists(t.id)&&(e.id="detail_"+t.id),e.data=t.data,e.level=t.level+1,t.detailNode=e,e}};u([K("columnModel")],E.prototype,"columnModel",2),u([K("beans")],E.prototype,"beans",2),E=u([ce("flattenStage")],E);import{_,Autowired as Q,Bean as ge,BeanStub as fe}from"@ag-grid-community/core";var D=class extends fe{sort(t,e,o,i,r,s){const n=this.gridOptionsService.get("groupMaintainOrder"),a=this.columnModel.getAllGridColumns().some(l=>l.isRowGroupActive());let p={};o&&i&&(p=this.calculateDirtyNodes(i));const h=this.columnModel.isPivotMode(),g=this.gridOptionsService.getCallback("postSortRows"),c=l=>{var R;this.pullDownGroupDataForHideOpenParents(l.childrenAfterAggFilter,!0);const v=h&&l.leafGroup;if(n&&a&&!l.leafGroup&&!s){const m=(R=this.columnModel.getRowGroupColumns())==null?void 0:R[l.level+1],X=m?.getSort()===null,V=l.childrenAfterAggFilter.slice(0);if(l.childrenAfterSort&&!X){const P={};l.childrenAfterSort.forEach((x,b)=>{P[x.id]=b}),V.sort((x,b)=>{var B,W;return((B=P[x.id])!=null?B:0)-((W=P[b.id])!=null?W:0)})}l.childrenAfterSort=V}else!e||v?l.childrenAfterSort=l.childrenAfterAggFilter.slice(0):o?l.childrenAfterSort=this.doDeltaSort(l,p,r,t):l.childrenAfterSort=this.rowNodeSorter.doFullSort(l.childrenAfterAggFilter,t);if(l.sibling&&(l.sibling.childrenAfterSort=l.childrenAfterSort),this.updateChildIndexes(l),g){const m={nodes:l.childrenAfterSort};g(m)}};r&&r.forEachChangedNodeDepthFirst(c),this.updateGroupDataForHideOpenParents(r)}calculateDirtyNodes(t){const e={},o=i=>{i&&i.forEach(r=>e[r.id]=!0)};return t&&t.forEach(i=>{o(i.add),o(i.update),o(i.remove)}),e}doDeltaSort(t,e,o,i){const r=t.childrenAfterAggFilter,s=t.childrenAfterSort;if(!s)return this.rowNodeSorter.doFullSort(r,i);const n={},a=[];r.forEach(c=>{e[c.id]||!o.canSkip(c)?a.push(c):n[c.id]=!0});const p=s.filter(c=>n[c.id]),h=(c,l)=>({currentPos:l,rowNode:c}),g=a.map(h).sort((c,l)=>this.rowNodeSorter.compareRowNodes(i,c,l));return this.mergeSortedArrays(i,g,p.map(h)).map(({rowNode:c})=>c)}mergeSortedArrays(t,e,o){const i=[];let r=0,s=0;for(;r<e.length&&s<o.length;)this.rowNodeSorter.compareRowNodes(t,e[r],o[s])<0?i.push(e[r++]):i.push(o[s++]);for(;r<e.length;)i.push(e[r++]);for(;s<o.length;)i.push(o[s++]);return i}updateChildIndexes(t){if(_.missing(t.childrenAfterSort))return;const e=t.childrenAfterSort;for(let o=0;o<e.length;o++){const i=e[o],r=o===0,s=o===t.childrenAfterSort.length-1;i.setFirstChild(r),i.setLastChild(s),i.setChildIndex(o)}}updateGroupDataForHideOpenParents(t){if(!this.gridOptionsService.get("groupHideOpenParents"))return;if(this.gridOptionsService.get("treeData"))return _.warnOnce("The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."),!1;const e=o=>{this.pullDownGroupDataForHideOpenParents(o.childrenAfterSort,!1),o.childrenAfterSort.forEach(i=>{i.hasChildren()&&e(i)})};t&&t.executeFromRootNode(o=>e(o))}pullDownGroupDataForHideOpenParents(t,e){!this.gridOptionsService.get("groupHideOpenParents")||_.missing(t)||t.forEach(o=>{this.columnModel.getGroupDisplayColumns().forEach(r=>{const s=r.getColDef().showRowGroup;if(typeof s!="string"){console.error("AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup");return}const n=s,a=this.columnModel.getPrimaryColumn(n);if(a!==o.rowGroupColumn)if(e)o.setGroupValue(r.getId(),void 0);else{const h=o.getFirstChildOfFirstChild(a);h&&o.setGroupValue(r.getId(),h.key)}})})}};u([Q("columnModel")],D.prototype,"columnModel",2),u([Q("rowNodeSorter")],D.prototype,"rowNodeSorter",2),D=u([ge("sortService")],D);import{Autowired as we,Bean as Re,BeanStub as Se}from"@ag-grid-community/core";var G=class extends Se{filter(t){const e=this.filterManager.isChildFilterPresent();this.filterNodes(e,t)}filterNodes(t,e){const o=(i,r)=>{i.hasChildren()&&t&&!r?i.childrenAfterFilter=i.childrenAfterGroup.filter(s=>{const n=s.childrenAfterFilter&&s.childrenAfterFilter.length>0,a=s.data&&this.filterManager.doesRowPassFilter({rowNode:s});return n||a}):i.childrenAfterFilter=i.childrenAfterGroup,i.sibling&&(i.sibling.childrenAfterFilter=i.childrenAfterFilter)};if(this.doingTreeDataFiltering()){const i=(s,n)=>{if(s.childrenAfterGroup)for(let a=0;a<s.childrenAfterGroup.length;a++){const p=s.childrenAfterGroup[a],h=n||this.filterManager.doesRowPassFilter({rowNode:p});p.childrenAfterGroup?i(s.childrenAfterGroup[a],h):o(p,h)}o(s,n)},r=s=>i(s,!1);e.executeFromRootNode(r)}else{const i=r=>o(r,!1);e.forEachChangedNodeDepthFirst(i,!0)}}doingTreeDataFiltering(){return this.gridOptionsService.get("treeData")&&!this.gridOptionsService.get("excludeChildrenWhenTreeDataFiltering")}};u([we("filterManager")],G.prototype,"filterManager",2),G=u([Re("filterService")],G);import{Autowired as k,Bean as ve,BeanStub as Ae,PostConstruct as Ce,_ as U}from"@ag-grid-community/core";var C=class extends Ae{postConstruct(){this.rowModel.getType()==="clientSide"&&(this.clientSideRowModel=this.rowModel,this.addManagedPropertyListener("rowData",()=>this.onRowDataUpdated()))}isActive(){const t=this.gridOptionsService.exists("getRowId");return this.gridOptionsService.get("resetRowDataOnUpdate")?!1:t}setRowData(t){const e=this.createTransactionForRowData(t);if(!e)return;const[o,i]=e;this.clientSideRowModel.updateRowData(o,i)}createTransactionForRowData(t){if(U.missing(this.clientSideRowModel)){console.error("AG Grid: ImmutableService only works with ClientSideRowModel");return}const e=this.gridOptionsService.getCallback("getRowId");if(e==null){console.error("AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");return}const o={remove:[],update:[],add:[]},i=this.clientSideRowModel.getCopyOfNodesMap(),s=this.gridOptionsService.get("suppressMaintainUnsortedOrder")?void 0:{};return U.exists(t)&&t.forEach((n,a)=>{const p=e({data:n,level:0}),h=i[p];s&&(s[p]=a),h?(h.data!==n&&o.update.push(n),i[p]=void 0):o.add.push(n)}),U.iterateObject(i,(n,a)=>{a&&o.remove.push(a.data)}),[o,s]}onRowDataUpdated(){const t=this.gridOptionsService.get("rowData");t&&(this.isActive()?this.setRowData(t):(this.selectionService.reset("rowDataChanged"),this.clientSideRowModel.setRowData(t)))}};u([k("rowModel")],C.prototype,"rowModel",2),u([k("rowRenderer")],C.prototype,"rowRenderer",2),u([k("selectionService")],C.prototype,"selectionService",2),u([Ce],C.prototype,"postConstruct",1),C=u([ve("immutableService")],C);var me="31.2.1",Te={version:me,moduleName:Z.ClientSideRowModelModule,rowModel:"clientSide",beans:[w,M,N,E,D,G,C]};export{Te as ClientSideRowModelModule};
