{"version":3,"sources":["webpack://ag-grid-vue3/webpack/universalModuleDefinition","webpack://ag-grid-vue3/webpack/bootstrap","webpack://ag-grid-vue3/external {\"commonjs\":\"vue\",\"commonjs2\":\"vue\",\"root\":\"Vue\"}","webpack://ag-grid-vue3/external \"agGrid\"","webpack://ag-grid-vue3/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://ag-grid-vue3/(webpack)/buildin/global.js","webpack://ag-grid-vue3/./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js","webpack://ag-grid-vue3/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://ag-grid-vue3/./src/Utils.ts","webpack://ag-grid-vue3/./src/VueComponentFactory.ts","webpack://ag-grid-vue3/./src/VueFrameworkComponentWrapper.ts","webpack://ag-grid-vue3/./src/VueFrameworkOverrides.ts","webpack://ag-grid-vue3/./src/AgGridVue.ts"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__8bbf__","__WEBPACK_EXTERNAL_MODULE__8bd4__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","makeMap","str","expectsLowerCase","set","Set","split","val","has","toLowerCase","NOOP","extend","assign","hasOwn","isArray","Array","isMap","toTypeString","isFunction","isString","isSymbol","isObject","objectToString","toString","toRawType","slice","isIntegerKey","parseInt","cacheStringFunction","fn","cache","hit","camelizeRE","hyphenateRE","replace","_","toUpperCase","capitalize","charAt","hasChanged","oldValue","is","def","obj","configurable","g","Function","e","window","currentScript","document","src","match","activeEffect","cleanupDepEffect","dep","effect2","trackId","_trackId","delete","size","cleanup","shouldTrack","pauseScheduleStack","trackStack","pauseTracking","push","resetTracking","last","pop","pauseScheduling","resetScheduling","queueEffectSchedulers","length","shift","trackEffect","debuggerEventExtraInfo","oldDep","deps","_depsLength","triggerEffects","dirtyLevel","keys","tracking","_dirtyLevel","_shouldSchedule","trigger","_runnings","allowRecurse","scheduler","createDep","computed","Map","targetMap","WeakMap","ITERATE_KEY","MAP_KEY_ITERATE_KEY","track","target","type","depsMap","newValue","oldTarget","values","newLength","Number","forEach","key2","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","filter","map","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","_isReadonly","_shallow","receiver","isReadonly2","shallow","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","getPrototypeOf","targetIsArray","Reflect","isRef","readonly","reactive","super","isOldValueReadonly","hadKey","result","deleteProperty","ownKeys","ReadonlyReactiveHandler","mutableHandlers","readonlyHandlers","toShallow","getProto","v","isReadonly","isShallow","rawTarget","rawKey","has2","wrap","toReadonly","toReactive","add","proto","get2","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","done","next","createReadonlyMethod","createInstrumentations","mutableInstrumentations2","shallowInstrumentations2","readonlyInstrumentations2","shallowReadonlyInstrumentations2","iteratorMethods","mutableInstrumentations","readonlyInstrumentations","shallowInstrumentations","shallowReadonlyInstrumentations","createInstrumentationGetter","mutableCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","raw","markRaw","__v_isRef","kebabProperty","kebabNameToAttrEventName","kebabName","substring","getAgGridProperties","props","eventNameAsProps","PUBLIC_EVENTS","eventName","undefined","options","ALL_PROPERTIES","propertyName","VUE_OMITTED_PROPERTY","gridOptions","watch","modelValue","currentValue","previousValue","gridCreated","api","every","item","index","processOnChange","rowData","deep","changes","entries","default","component","parent","componentDefinition","searchForComponentInstance","extends","console","error","setup","addParamsToProps","indexOf","params","provides","getComponentDefinition","vNode","destroy","el","mount","freeze","componentInstance","element","appContext","$","$parent","$options","provide","createElement","maxDepth","suppressError","currentParent","depth","currentParentAsThis","components","that","DynamicComponent","VueComponent","init","wrapper","getFrameworkComponentInstance","setupState","frameworkComponentInstance","methodName","autoParamsRefresh","hasMethod","callMethod","createComponent","createAndMountComponent","mandatory","overrideProcessing","processMethod","arguments","warn","unmount","firstElementChild","indirectName","comp","ROW_DATA_EVENTS","ALWAYS_SYNC_GLOBAL_EVENTS","EVENT_GRID_PRE_DESTROYED","DATA_MODEL_ATTR_NAME","DATA_MODEL_EMIT_NAME","AgGridVue","Boolean","componentDependencies","plugins","required","isDestroyed","gridReadyFired","emitRowModel","methods","restrictToSyncOnly","eventType","event","alwaysSync","updateModelIfUsed","skipChange","isFrozen","thisAsAny","forEachNode","rowNode","data","$attrs","instance","currentRowData","previousRowData","func","delay","timeout","later","clearTimeout","setTimeout","debounce","$emit","getRowData","getProvides","frameworkComponentWrapper","combineAttributesAndGridOptions","checkForBindingConflicts","getRowDataBasedOnBindings","gridParams","globalEventListener","globalEventListenerFactory","globalSyncEventListener","frameworkOverrides","providedBeanInstances","$el"],"mappings":"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","file":"ag-grid-vue3.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"vue\"), require(\"agGrid\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([, \"agGrid\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ag-grid-vue3\"] = factory(require(\"vue\"), require(\"agGrid\"));\n\telse\n\t\troot[\"ag-grid-vue3\"] = factory(root[\"Vue\"], root[\"agGrid\"]);\n})((typeof self !== 'undefined' ? self : this), function(__WEBPACK_EXTERNAL_MODULE__8bbf__, __WEBPACK_EXTERNAL_MODULE__8bd4__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"fae3\");\n","module.exports = __WEBPACK_EXTERNAL_MODULE__8bbf__;","module.exports = __WEBPACK_EXTERNAL_MODULE__8bd4__;","/**\n* @vue/shared v3.4.19\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction makeMap(str, expectsLowerCase) {\n  const set = new Set(str.split(\",\"));\n  return expectsLowerCase ? (val) => set.has(val.toLowerCase()) : (val) => set.has(val);\n}\n\nconst EMPTY_OBJ = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze({}) : {};\nconst EMPTY_ARR = !!(process.env.NODE_ENV !== \"production\") ? Object.freeze([]) : [];\nconst NOOP = () => {\n};\nconst NO = () => false;\nconst isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter\n(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);\nconst isModelListener = (key) => key.startsWith(\"onUpdate:\");\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n  const i = arr.indexOf(el);\n  if (i > -1) {\n    arr.splice(i, 1);\n  }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === \"[object Map]\";\nconst isSet = (val) => toTypeString(val) === \"[object Set]\";\nconst isDate = (val) => toTypeString(val) === \"[object Date]\";\nconst isRegExp = (val) => toTypeString(val) === \"[object RegExp]\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isString = (val) => typeof val === \"string\";\nconst isSymbol = (val) => typeof val === \"symbol\";\nconst isObject = (val) => val !== null && typeof val === \"object\";\nconst isPromise = (val) => {\n  return (isObject(val) || isFunction(val)) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n  return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === \"[object Object]\";\nconst isIntegerKey = (key) => isString(key) && key !== \"NaN\" && key[0] !== \"-\" && \"\" + parseInt(key, 10) === key;\nconst isReservedProp = /* @__PURE__ */ makeMap(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n);\nconst isBuiltInDirective = /* @__PURE__ */ makeMap(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n);\nconst cacheStringFunction = (fn) => {\n  const cache = /* @__PURE__ */ Object.create(null);\n  return (str) => {\n    const hit = cache[str];\n    return hit || (cache[str] = fn(str));\n  };\n};\nconst camelizeRE = /-(\\w)/g;\nconst camelize = cacheStringFunction((str) => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : \"\");\n});\nconst hyphenateRE = /\\B([A-Z])/g;\nconst hyphenate = cacheStringFunction(\n  (str) => str.replace(hyphenateRE, \"-$1\").toLowerCase()\n);\nconst capitalize = cacheStringFunction((str) => {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n});\nconst toHandlerKey = cacheStringFunction((str) => {\n  const s = str ? `on${capitalize(str)}` : ``;\n  return s;\n});\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n  for (let i = 0; i < fns.length; i++) {\n    fns[i](arg);\n  }\n};\nconst def = (obj, key, value) => {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: false,\n    value\n  });\n};\nconst looseToNumber = (val) => {\n  const n = parseFloat(val);\n  return isNaN(n) ? val : n;\n};\nconst toNumber = (val) => {\n  const n = isString(val) ? Number(val) : NaN;\n  return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n  return _globalThis || (_globalThis = typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {});\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n  return identRE.test(name) ? `__props.${name}` : `__props[${JSON.stringify(name)}]`;\n}\n\nconst PatchFlags = {\n  \"TEXT\": 1,\n  \"1\": \"TEXT\",\n  \"CLASS\": 2,\n  \"2\": \"CLASS\",\n  \"STYLE\": 4,\n  \"4\": \"STYLE\",\n  \"PROPS\": 8,\n  \"8\": \"PROPS\",\n  \"FULL_PROPS\": 16,\n  \"16\": \"FULL_PROPS\",\n  \"NEED_HYDRATION\": 32,\n  \"32\": \"NEED_HYDRATION\",\n  \"STABLE_FRAGMENT\": 64,\n  \"64\": \"STABLE_FRAGMENT\",\n  \"KEYED_FRAGMENT\": 128,\n  \"128\": \"KEYED_FRAGMENT\",\n  \"UNKEYED_FRAGMENT\": 256,\n  \"256\": \"UNKEYED_FRAGMENT\",\n  \"NEED_PATCH\": 512,\n  \"512\": \"NEED_PATCH\",\n  \"DYNAMIC_SLOTS\": 1024,\n  \"1024\": \"DYNAMIC_SLOTS\",\n  \"DEV_ROOT_FRAGMENT\": 2048,\n  \"2048\": \"DEV_ROOT_FRAGMENT\",\n  \"HOISTED\": -1,\n  \"-1\": \"HOISTED\",\n  \"BAIL\": -2,\n  \"-2\": \"BAIL\"\n};\nconst PatchFlagNames = {\n  [1]: `TEXT`,\n  [2]: `CLASS`,\n  [4]: `STYLE`,\n  [8]: `PROPS`,\n  [16]: `FULL_PROPS`,\n  [32]: `NEED_HYDRATION`,\n  [64]: `STABLE_FRAGMENT`,\n  [128]: `KEYED_FRAGMENT`,\n  [256]: `UNKEYED_FRAGMENT`,\n  [512]: `NEED_PATCH`,\n  [1024]: `DYNAMIC_SLOTS`,\n  [2048]: `DEV_ROOT_FRAGMENT`,\n  [-1]: `HOISTED`,\n  [-2]: `BAIL`\n};\n\nconst ShapeFlags = {\n  \"ELEMENT\": 1,\n  \"1\": \"ELEMENT\",\n  \"FUNCTIONAL_COMPONENT\": 2,\n  \"2\": \"FUNCTIONAL_COMPONENT\",\n  \"STATEFUL_COMPONENT\": 4,\n  \"4\": \"STATEFUL_COMPONENT\",\n  \"TEXT_CHILDREN\": 8,\n  \"8\": \"TEXT_CHILDREN\",\n  \"ARRAY_CHILDREN\": 16,\n  \"16\": \"ARRAY_CHILDREN\",\n  \"SLOTS_CHILDREN\": 32,\n  \"32\": \"SLOTS_CHILDREN\",\n  \"TELEPORT\": 64,\n  \"64\": \"TELEPORT\",\n  \"SUSPENSE\": 128,\n  \"128\": \"SUSPENSE\",\n  \"COMPONENT_SHOULD_KEEP_ALIVE\": 256,\n  \"256\": \"COMPONENT_SHOULD_KEEP_ALIVE\",\n  \"COMPONENT_KEPT_ALIVE\": 512,\n  \"512\": \"COMPONENT_KEPT_ALIVE\",\n  \"COMPONENT\": 6,\n  \"6\": \"COMPONENT\"\n};\n\nconst SlotFlags = {\n  \"STABLE\": 1,\n  \"1\": \"STABLE\",\n  \"DYNAMIC\": 2,\n  \"2\": \"DYNAMIC\",\n  \"FORWARDED\": 3,\n  \"3\": \"FORWARDED\"\n};\nconst slotFlagsText = {\n  [1]: \"STABLE\",\n  [2]: \"DYNAMIC\",\n  [3]: \"FORWARDED\"\n};\n\nconst GLOBALS_ALLOWED = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error\";\nconst isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);\nconst isGloballyWhitelisted = isGloballyAllowed;\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n  let lines = source.split(/(\\r?\\n)/);\n  const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n  lines = lines.filter((_, idx) => idx % 2 === 0);\n  let count = 0;\n  const res = [];\n  for (let i = 0; i < lines.length; i++) {\n    count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);\n    if (count >= start) {\n      for (let j = i - range; j <= i + range || end > count; j++) {\n        if (j < 0 || j >= lines.length)\n          continue;\n        const line = j + 1;\n        res.push(\n          `${line}${\" \".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`\n        );\n        const lineLength = lines[j].length;\n        const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;\n        if (j === i) {\n          const pad = start - (count - (lineLength + newLineSeqLength));\n          const length = Math.max(\n            1,\n            end > count ? lineLength - pad : end - start\n          );\n          res.push(`   |  ` + \" \".repeat(pad) + \"^\".repeat(length));\n        } else if (j > i) {\n          if (end > count) {\n            const length = Math.max(Math.min(end - count, lineLength), 1);\n            res.push(`   |  ` + \"^\".repeat(length));\n          }\n          count += lineLength + newLineSeqLength;\n        }\n      }\n      break;\n    }\n  }\n  return res.join(\"\\n\");\n}\n\nfunction normalizeStyle(value) {\n  if (isArray(value)) {\n    const res = {};\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i];\n      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);\n      if (normalized) {\n        for (const key in normalized) {\n          res[key] = normalized[key];\n        }\n      }\n    }\n    return res;\n  } else if (isString(value) || isObject(value)) {\n    return value;\n  }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*[^]*?\\*\\//g;\nfunction parseStringStyle(cssText) {\n  const ret = {};\n  cssText.replace(styleCommentRE, \"\").split(listDelimiterRE).forEach((item) => {\n    if (item) {\n      const tmp = item.split(propertyDelimiterRE);\n      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return ret;\n}\nfunction stringifyStyle(styles) {\n  let ret = \"\";\n  if (!styles || isString(styles)) {\n    return ret;\n  }\n  for (const key in styles) {\n    const value = styles[key];\n    const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n    if (isString(value) || typeof value === \"number\") {\n      ret += `${normalizedKey}:${value};`;\n    }\n  }\n  return ret;\n}\nfunction normalizeClass(value) {\n  let res = \"\";\n  if (isString(value)) {\n    res = value;\n  } else if (isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const normalized = normalizeClass(value[i]);\n      if (normalized) {\n        res += normalized + \" \";\n      }\n    }\n  } else if (isObject(value)) {\n    for (const name in value) {\n      if (value[name]) {\n        res += name + \" \";\n      }\n    }\n  }\n  return res.trim();\n}\nfunction normalizeProps(props) {\n  if (!props)\n    return null;\n  let { class: klass, style } = props;\n  if (klass && !isString(klass)) {\n    props.class = normalizeClass(klass);\n  }\n  if (style) {\n    props.style = normalizeStyle(style);\n  }\n  return props;\n}\n\nconst HTML_TAGS = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\";\nconst SVG_TAGS = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\";\nconst MATH_TAGS = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\";\nconst VOID_TAGS = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\";\nconst isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);\nconst isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);\nconst isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);\nconst isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);\n\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);\nconst isBooleanAttr = /* @__PURE__ */ makeMap(\n  specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`\n);\nfunction includeBooleanAttr(value) {\n  return !!value || value === \"\";\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n  if (attrValidationCache.hasOwnProperty(name)) {\n    return attrValidationCache[name];\n  }\n  const isUnsafe = unsafeAttrCharRE.test(name);\n  if (isUnsafe) {\n    console.error(`unsafe attribute name: ${name}`);\n  }\n  return attrValidationCache[name] = !isUnsafe;\n}\nconst propsToAttrMap = {\n  acceptCharset: \"accept-charset\",\n  className: \"class\",\n  htmlFor: \"for\",\n  httpEquiv: \"http-equiv\"\n};\nconst isKnownHtmlAttr = /* @__PURE__ */ makeMap(\n  `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`\n);\nconst isKnownSvgAttr = /* @__PURE__ */ makeMap(\n  `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`\n);\nfunction isRenderableAttrValue(value) {\n  if (value == null) {\n    return false;\n  }\n  const type = typeof value;\n  return type === \"string\" || type === \"number\" || type === \"boolean\";\n}\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n  const str = \"\" + string;\n  const match = escapeRE.exec(str);\n  if (!match) {\n    return str;\n  }\n  let html = \"\";\n  let escaped;\n  let index;\n  let lastIndex = 0;\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34:\n        escaped = \"&quot;\";\n        break;\n      case 38:\n        escaped = \"&amp;\";\n        break;\n      case 39:\n        escaped = \"&#39;\";\n        break;\n      case 60:\n        escaped = \"&lt;\";\n        break;\n      case 62:\n        escaped = \"&gt;\";\n        break;\n      default:\n        continue;\n    }\n    if (lastIndex !== index) {\n      html += str.slice(lastIndex, index);\n    }\n    lastIndex = index + 1;\n    html += escaped;\n  }\n  return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n  return src.replace(commentStripRE, \"\");\n}\n\nfunction looseCompareArrays(a, b) {\n  if (a.length !== b.length)\n    return false;\n  let equal = true;\n  for (let i = 0; equal && i < a.length; i++) {\n    equal = looseEqual(a[i], b[i]);\n  }\n  return equal;\n}\nfunction looseEqual(a, b) {\n  if (a === b)\n    return true;\n  let aValidType = isDate(a);\n  let bValidType = isDate(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n  }\n  aValidType = isSymbol(a);\n  bValidType = isSymbol(b);\n  if (aValidType || bValidType) {\n    return a === b;\n  }\n  aValidType = isArray(a);\n  bValidType = isArray(b);\n  if (aValidType || bValidType) {\n    return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n  }\n  aValidType = isObject(a);\n  bValidType = isObject(b);\n  if (aValidType || bValidType) {\n    if (!aValidType || !bValidType) {\n      return false;\n    }\n    const aKeysCount = Object.keys(a).length;\n    const bKeysCount = Object.keys(b).length;\n    if (aKeysCount !== bKeysCount) {\n      return false;\n    }\n    for (const key in a) {\n      const aHasKey = a.hasOwnProperty(key);\n      const bHasKey = b.hasOwnProperty(key);\n      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n  }\n  return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n  return arr.findIndex((item) => looseEqual(item, val));\n}\n\nconst toDisplayString = (val) => {\n  return isString(val) ? val : val == null ? \"\" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);\n};\nconst replacer = (_key, val) => {\n  if (val && val.__v_isRef) {\n    return replacer(_key, val.value);\n  } else if (isMap(val)) {\n    return {\n      [`Map(${val.size})`]: [...val.entries()].reduce(\n        (entries, [key, val2], i) => {\n          entries[stringifySymbol(key, i) + \" =>\"] = val2;\n          return entries;\n        },\n        {}\n      )\n    };\n  } else if (isSet(val)) {\n    return {\n      [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))\n    };\n  } else if (isSymbol(val)) {\n    return stringifySymbol(val);\n  } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n    return String(val);\n  }\n  return val;\n};\nconst stringifySymbol = (v, i = \"\") => {\n  var _a;\n  return isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, PatchFlags, ShapeFlags, SlotFlags, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyAllowed, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isMathMLTag, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isRenderableAttrValue, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","// This file is imported into lib/wc client bundles.\n\nif (typeof window !== 'undefined') {\n  var currentScript = window.document.currentScript\n  if (process.env.NEED_CURRENTSCRIPT_POLYFILL) {\n    var getCurrentScript = require('@soda/get-current-script')\n    currentScript = getCurrentScript()\n\n    // for backward compatibility, because previously we directly included the polyfill\n    if (!('currentScript' in document)) {\n      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })\n    }\n  }\n\n  var src = currentScript && currentScript.src.match(/(.+\\/)[^/]+\\.js(\\?.*)?$/)\n  if (src) {\n    __webpack_public_path__ = src[1] // eslint-disable-line\n  }\n}\n\n// Indicate to webpack that this file can be concatenated\nexport default null\n","/**\n* @vue/reactivity v3.4.19\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nimport { NOOP, extend, isArray, isSymbol, isMap, isIntegerKey, hasOwn, hasChanged, isObject, makeMap, capitalize, toRawType, def, isFunction } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n  constructor(detached = false) {\n    this.detached = detached;\n    /**\n     * @internal\n     */\n    this._active = true;\n    /**\n     * @internal\n     */\n    this.effects = [];\n    /**\n     * @internal\n     */\n    this.cleanups = [];\n    this.parent = activeEffectScope;\n    if (!detached && activeEffectScope) {\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(\n        this\n      ) - 1;\n    }\n  }\n  get active() {\n    return this._active;\n  }\n  run(fn) {\n    if (this._active) {\n      const currentEffectScope = activeEffectScope;\n      try {\n        activeEffectScope = this;\n        return fn();\n      } finally {\n        activeEffectScope = currentEffectScope;\n      }\n    } else if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    activeEffectScope = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    activeEffectScope = this.parent;\n  }\n  stop(fromParent) {\n    if (this._active) {\n      let i, l;\n      for (i = 0, l = this.effects.length; i < l; i++) {\n        this.effects[i].stop();\n      }\n      for (i = 0, l = this.cleanups.length; i < l; i++) {\n        this.cleanups[i]();\n      }\n      if (this.scopes) {\n        for (i = 0, l = this.scopes.length; i < l; i++) {\n          this.scopes[i].stop(true);\n        }\n      }\n      if (!this.detached && this.parent && !fromParent) {\n        const last = this.parent.scopes.pop();\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n      this.parent = void 0;\n      this._active = false;\n    }\n  }\n}\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    warn(\n      `onScopeDispose() is called when there is no active effect scope to be associated with.`\n    );\n  }\n}\n\nlet activeEffect;\nclass ReactiveEffect {\n  constructor(fn, trigger, scheduler, scope) {\n    this.fn = fn;\n    this.trigger = trigger;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    /**\n     * @internal\n     */\n    this._dirtyLevel = 4;\n    /**\n     * @internal\n     */\n    this._trackId = 0;\n    /**\n     * @internal\n     */\n    this._runnings = 0;\n    /**\n     * @internal\n     */\n    this._shouldSchedule = false;\n    /**\n     * @internal\n     */\n    this._depsLength = 0;\n    recordEffectScope(this, scope);\n  }\n  get dirty() {\n    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {\n      this._dirtyLevel = 1;\n      pauseTracking();\n      for (let i = 0; i < this._depsLength; i++) {\n        const dep = this.deps[i];\n        if (dep.computed) {\n          triggerComputed(dep.computed);\n          if (this._dirtyLevel >= 4) {\n            break;\n          }\n        }\n      }\n      if (this._dirtyLevel === 1) {\n        this._dirtyLevel = 0;\n      }\n      resetTracking();\n    }\n    return this._dirtyLevel >= 4;\n  }\n  set dirty(v) {\n    this._dirtyLevel = v ? 4 : 0;\n  }\n  run() {\n    this._dirtyLevel = 0;\n    if (!this.active) {\n      return this.fn();\n    }\n    let lastShouldTrack = shouldTrack;\n    let lastEffect = activeEffect;\n    try {\n      shouldTrack = true;\n      activeEffect = this;\n      this._runnings++;\n      preCleanupEffect(this);\n      return this.fn();\n    } finally {\n      postCleanupEffect(this);\n      this._runnings--;\n      activeEffect = lastEffect;\n      shouldTrack = lastShouldTrack;\n    }\n  }\n  stop() {\n    var _a;\n    if (this.active) {\n      preCleanupEffect(this);\n      postCleanupEffect(this);\n      (_a = this.onStop) == null ? void 0 : _a.call(this);\n      this.active = false;\n    }\n  }\n}\nfunction triggerComputed(computed) {\n  return computed.value;\n}\nfunction preCleanupEffect(effect2) {\n  effect2._trackId++;\n  effect2._depsLength = 0;\n}\nfunction postCleanupEffect(effect2) {\n  if (effect2.deps.length > effect2._depsLength) {\n    for (let i = effect2._depsLength; i < effect2.deps.length; i++) {\n      cleanupDepEffect(effect2.deps[i], effect2);\n    }\n    effect2.deps.length = effect2._depsLength;\n  }\n}\nfunction cleanupDepEffect(dep, effect2) {\n  const trackId = dep.get(effect2);\n  if (trackId !== void 0 && effect2._trackId !== trackId) {\n    dep.delete(effect2);\n    if (dep.size === 0) {\n      dep.cleanup();\n    }\n  }\n}\nfunction effect(fn, options) {\n  if (fn.effect instanceof ReactiveEffect) {\n    fn = fn.effect.fn;\n  }\n  const _effect = new ReactiveEffect(fn, NOOP, () => {\n    if (_effect.dirty) {\n      _effect.run();\n    }\n  });\n  if (options) {\n    extend(_effect, options);\n    if (options.scope)\n      recordEffectScope(_effect, options.scope);\n  }\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n  const runner = _effect.run.bind(_effect);\n  runner.effect = _effect;\n  return runner;\n}\nfunction stop(runner) {\n  runner.effect.stop();\n}\nlet shouldTrack = true;\nlet pauseScheduleStack = 0;\nconst trackStack = [];\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === void 0 ? true : last;\n}\nfunction pauseScheduling() {\n  pauseScheduleStack++;\n}\nfunction resetScheduling() {\n  pauseScheduleStack--;\n  while (!pauseScheduleStack && queueEffectSchedulers.length) {\n    queueEffectSchedulers.shift()();\n  }\n}\nfunction trackEffect(effect2, dep, debuggerEventExtraInfo) {\n  var _a;\n  if (dep.get(effect2) !== effect2._trackId) {\n    dep.set(effect2, effect2._trackId);\n    const oldDep = effect2.deps[effect2._depsLength];\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect2);\n      }\n      effect2.deps[effect2._depsLength++] = dep;\n    } else {\n      effect2._depsLength++;\n    }\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      (_a = effect2.onTrack) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));\n    }\n  }\n}\nconst queueEffectSchedulers = [];\nfunction triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {\n  var _a;\n  pauseScheduling();\n  for (const effect2 of dep.keys()) {\n    let tracking;\n    if (effect2._dirtyLevel < dirtyLevel && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n      effect2._shouldSchedule || (effect2._shouldSchedule = effect2._dirtyLevel === 0);\n      effect2._dirtyLevel = dirtyLevel;\n    }\n    if (effect2._shouldSchedule && (tracking != null ? tracking : tracking = dep.get(effect2) === effect2._trackId)) {\n      if (!!(process.env.NODE_ENV !== \"production\")) {\n        (_a = effect2.onTrigger) == null ? void 0 : _a.call(effect2, extend({ effect: effect2 }, debuggerEventExtraInfo));\n      }\n      effect2.trigger();\n      if ((!effect2._runnings || effect2.allowRecurse) && effect2._dirtyLevel !== 2) {\n        effect2._shouldSchedule = false;\n        if (effect2.scheduler) {\n          queueEffectSchedulers.push(effect2.scheduler);\n        }\n      }\n    }\n  }\n  resetScheduling();\n}\n\nconst createDep = (cleanup, computed) => {\n  const dep = /* @__PURE__ */ new Map();\n  dep.cleanup = cleanup;\n  dep.computed = computed;\n  return dep;\n};\n\nconst targetMap = /* @__PURE__ */ new WeakMap();\nconst ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"iterate\" : \"\");\nconst MAP_KEY_ITERATE_KEY = Symbol(!!(process.env.NODE_ENV !== \"production\") ? \"Map key iterate\" : \"\");\nfunction track(target, type, key) {\n  if (shouldTrack && activeEffect) {\n    let depsMap = targetMap.get(target);\n    if (!depsMap) {\n      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());\n    }\n    let dep = depsMap.get(key);\n    if (!dep) {\n      depsMap.set(key, dep = createDep(() => depsMap.delete(key)));\n    }\n    trackEffect(\n      activeEffect,\n      dep,\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target,\n        type,\n        key\n      } : void 0\n    );\n  }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n  if (!depsMap) {\n    return;\n  }\n  let deps = [];\n  if (type === \"clear\") {\n    deps = [...depsMap.values()];\n  } else if (key === \"length\" && isArray(target)) {\n    const newLength = Number(newValue);\n    depsMap.forEach((dep, key2) => {\n      if (key2 === \"length\" || !isSymbol(key2) && key2 >= newLength) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    }\n    switch (type) {\n      case \"add\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          deps.push(depsMap.get(\"length\"));\n        }\n        break;\n      case \"delete\":\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n        break;\n      case \"set\":\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n        break;\n    }\n  }\n  pauseScheduling();\n  for (const dep of deps) {\n    if (dep) {\n      triggerEffects(\n        dep,\n        4,\n        !!(process.env.NODE_ENV !== \"production\") ? {\n          target,\n          type,\n          key,\n          newValue,\n          oldValue,\n          oldTarget\n        } : void 0\n      );\n    }\n  }\n  resetScheduling();\n}\nfunction getDepFromReactive(object, key) {\n  var _a;\n  return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== \"arguments\" && key !== \"caller\").map((key) => Symbol[key]).filter(isSymbol)\n);\nconst arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      const arr = toRaw(this);\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\", i + \"\");\n      }\n      const res = arr[key](...args);\n      if (res === -1 || res === false) {\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((key) => {\n    instrumentations[key] = function(...args) {\n      pauseTracking();\n      pauseScheduling();\n      const res = toRaw(this)[key].apply(this, args);\n      resetScheduling();\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\nfunction hasOwnProperty(key) {\n  const obj = toRaw(this);\n  track(obj, \"has\", key);\n  return obj.hasOwnProperty(key);\n}\nclass BaseReactiveHandler {\n  constructor(_isReadonly = false, _shallow = false) {\n    this._isReadonly = _isReadonly;\n    this._shallow = _shallow;\n  }\n  get(target, key, receiver) {\n    const isReadonly2 = this._isReadonly, shallow = this._shallow;\n    if (key === \"__v_isReactive\") {\n      return !isReadonly2;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly2;\n    } else if (key === \"__v_isShallow\") {\n      return shallow;\n    } else if (key === \"__v_raw\") {\n      if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the reciever is a user proxy of the reactive proxy\n      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {\n        return target;\n      }\n      return;\n    }\n    const targetIsArray = isArray(target);\n    if (!isReadonly2) {\n      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n        return Reflect.get(arrayInstrumentations, key, receiver);\n      }\n      if (key === \"hasOwnProperty\") {\n        return hasOwnProperty;\n      }\n    }\n    const res = Reflect.get(target, key, receiver);\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n    if (!isReadonly2) {\n      track(target, \"get\", key);\n    }\n    if (shallow) {\n      return res;\n    }\n    if (isRef(res)) {\n      return targetIsArray && isIntegerKey(key) ? res : res.value;\n    }\n    if (isObject(res)) {\n      return isReadonly2 ? readonly(res) : reactive(res);\n    }\n    return res;\n  }\n}\nclass MutableReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(false, shallow);\n  }\n  set(target, key, value, receiver) {\n    let oldValue = target[key];\n    if (!this._shallow) {\n      const isOldValueReadonly = isReadonly(oldValue);\n      if (!isShallow(value) && !isReadonly(value)) {\n        oldValue = toRaw(oldValue);\n        value = toRaw(value);\n      }\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        if (isOldValueReadonly) {\n          return false;\n        } else {\n          oldValue.value = value;\n          return true;\n        }\n      }\n    }\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver);\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\", key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\", key, value, oldValue);\n      }\n    }\n    return result;\n  }\n  deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n      trigger(target, \"delete\", key, void 0, oldValue);\n    }\n    return result;\n  }\n  has(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n      track(target, \"has\", key);\n    }\n    return result;\n  }\n  ownKeys(target) {\n    track(\n      target,\n      \"iterate\",\n      isArray(target) ? \"length\" : ITERATE_KEY\n    );\n    return Reflect.ownKeys(target);\n  }\n}\nclass ReadonlyReactiveHandler extends BaseReactiveHandler {\n  constructor(shallow = false) {\n    super(true, shallow);\n  }\n  set(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Set operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n  deleteProperty(target, key) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      warn(\n        `Delete operation on key \"${String(key)}\" failed: target is readonly.`,\n        target\n      );\n    }\n    return true;\n  }\n}\nconst mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();\nconst readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();\nconst shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(\n  true\n);\nconst shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n  target = target[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"get\", key);\n    }\n    track(rawTarget, \"get\", rawKey);\n  }\n  const { has: has2 } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n  if (has2.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has2.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    target.get(key);\n  }\n}\nfunction has(key, isReadonly = false) {\n  const target = this[\"__v_raw\"];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n  if (!isReadonly) {\n    if (hasChanged(key, rawKey)) {\n      track(rawTarget, \"has\", key);\n    }\n    track(rawTarget, \"has\", rawKey);\n  }\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"];\n  !isReadonly && track(toRaw(target), \"iterate\", ITERATE_KEY);\n  return Reflect.get(target, \"size\", target);\n}\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\", value, value);\n  }\n  return this;\n}\nfunction set(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2.call(target, key);\n  target.set(key, value);\n  if (!hadKey) {\n    trigger(target, \"add\", key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\", key, value, oldValue);\n  }\n  return this;\n}\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const { has: has2, get: get2 } = getProto(target);\n  let hadKey = has2.call(target, key);\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has2.call(target, key);\n  } else if (!!(process.env.NODE_ENV !== \"production\")) {\n    checkIdentityKeys(target, has2, key);\n  }\n  const oldValue = get2 ? get2.call(target, key) : void 0;\n  const result = target.delete(key);\n  if (hadKey) {\n    trigger(target, \"delete\", key, void 0, oldValue);\n  }\n  return result;\n}\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = !!(process.env.NODE_ENV !== \"production\") ? isMap(target) ? new Map(target) : new Set(target) : void 0;\n  const result = target.clear();\n  if (hadItems) {\n    trigger(target, \"clear\", void 0, void 0, oldTarget);\n  }\n  return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\", ITERATE_KEY);\n    return target.forEach((value, key) => {\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function(...args) {\n    const target = this[\"__v_raw\"];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === \"entries\" || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === \"keys\" && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(\n      rawTarget,\n      \"iterate\",\n      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY\n    );\n    return {\n      // iterator protocol\n      next() {\n        const { value, done } = innerIterator.next();\n        return done ? { value, done } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction createReadonlyMethod(type) {\n  return function(...args) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(\n        `${capitalize(type)} operation ${key}failed: target is readonly.`,\n        toRaw(this)\n      );\n    }\n    return type === \"delete\" ? false : type === \"clear\" ? void 0 : this;\n  };\n}\nfunction createInstrumentations() {\n  const mutableInstrumentations2 = {\n    get(key) {\n      return get(this, key);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations2 = {\n    get(key) {\n      return get(this, key, false, true);\n    },\n    get size() {\n      return size(this);\n    },\n    has,\n    add,\n    set,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations2 = {\n    get(key) {\n      return get(this, key, true, true);\n    },\n    get size() {\n      return size(this, true);\n    },\n    has(key) {\n      return has.call(this, key, true);\n    },\n    add: createReadonlyMethod(\"add\"),\n    set: createReadonlyMethod(\"set\"),\n    delete: createReadonlyMethod(\"delete\"),\n    clear: createReadonlyMethod(\"clear\"),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = [\"keys\", \"values\", \"entries\", Symbol.iterator];\n  iteratorMethods.forEach((method) => {\n    mutableInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      false\n    );\n    readonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      false\n    );\n    shallowInstrumentations2[method] = createIterableMethod(\n      method,\n      false,\n      true\n    );\n    shallowReadonlyInstrumentations2[method] = createIterableMethod(\n      method,\n      true,\n      true\n    );\n  });\n  return [\n    mutableInstrumentations2,\n    readonlyInstrumentations2,\n    shallowInstrumentations2,\n    shallowReadonlyInstrumentations2\n  ];\n}\nconst [\n  mutableInstrumentations,\n  readonlyInstrumentations,\n  shallowInstrumentations,\n  shallowReadonlyInstrumentations\n] = /* @__PURE__ */ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\") {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\") {\n      return isReadonly;\n    } else if (key === \"__v_raw\") {\n      return target;\n    }\n    return Reflect.get(\n      hasOwn(instrumentations, key) && key in target ? instrumentations : target,\n      key,\n      receiver\n    );\n  };\n}\nconst mutableCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /* @__PURE__ */ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has2, key) {\n  const rawKey = toRaw(key);\n  if (rawKey !== key && has2.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(\n      `Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\n\nconst reactiveMap = /* @__PURE__ */ new WeakMap();\nconst shallowReactiveMap = /* @__PURE__ */ new WeakMap();\nconst readonlyMap = /* @__PURE__ */ new WeakMap();\nconst shallowReadonlyMap = /* @__PURE__ */ new WeakMap();\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case \"Object\":\n    case \"Array\":\n      return 1 /* COMMON */;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2 /* COLLECTION */;\n    default:\n      return 0 /* INVALID */;\n  }\n}\nfunction getTargetType(value) {\n  return value[\"__v_skip\"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n  if (isReadonly(target)) {\n    return target;\n  }\n  return createReactiveObject(\n    target,\n    false,\n    mutableHandlers,\n    mutableCollectionHandlers,\n    reactiveMap\n  );\n}\nfunction shallowReactive(target) {\n  return createReactiveObject(\n    target,\n    false,\n    shallowReactiveHandlers,\n    shallowCollectionHandlers,\n    shallowReactiveMap\n  );\n}\nfunction readonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    readonlyHandlers,\n    readonlyCollectionHandlers,\n    readonlyMap\n  );\n}\nfunction shallowReadonly(target) {\n  return createReactiveObject(\n    target,\n    true,\n    shallowReadonlyHandlers,\n    shallowReadonlyCollectionHandlers,\n    shallowReadonlyMap\n  );\n}\nfunction createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (!!(process.env.NODE_ENV !== \"production\")) {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n    return target;\n  }\n  if (target[\"__v_raw\"] && !(isReadonly2 && target[\"__v_isReactive\"])) {\n    return target;\n  }\n  const existingProxy = proxyMap.get(target);\n  if (existingProxy) {\n    return existingProxy;\n  }\n  const targetType = getTargetType(target);\n  if (targetType === 0 /* INVALID */) {\n    return target;\n  }\n  const proxy = new Proxy(\n    target,\n    targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers\n  );\n  proxyMap.set(target, proxy);\n  return proxy;\n}\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"]);\n  }\n  return !!(value && value[\"__v_isReactive\"]);\n}\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"]);\n}\nfunction isShallow(value) {\n  return !!(value && value[\"__v_isShallow\"]);\n}\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"];\n  return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n  if (Object.isExtensible(value)) {\n    def(value, \"__v_skip\", true);\n  }\n  return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nconst COMPUTED_SIDE_EFFECT_WARN = `Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free`;\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly, isSSR) {\n    this._setter = _setter;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this[\"__v_isReadonly\"] = false;\n    this.effect = new ReactiveEffect(\n      () => getter(this._value),\n      () => triggerRefValue(\n        this,\n        this.effect._dirtyLevel === 2 ? 2 : 3\n      )\n    );\n    this.effect.computed = this;\n    this.effect.active = this._cacheable = !isSSR;\n    this[\"__v_isReadonly\"] = isReadonly;\n  }\n  get value() {\n    const self = toRaw(this);\n    if ((!self._cacheable || self.effect.dirty) && hasChanged(self._value, self._value = self.effect.run())) {\n      triggerRefValue(self, 4);\n    }\n    trackRefValue(self);\n    if (self.effect._dirtyLevel >= 2) {\n      !!(process.env.NODE_ENV !== \"production\") && warn(COMPUTED_SIDE_EFFECT_WARN);\n      triggerRefValue(self, 2);\n    }\n    return self._value;\n  }\n  set value(newValue) {\n    this._setter(newValue);\n  }\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\n  get _dirty() {\n    return this.effect.dirty;\n  }\n  set _dirty(v) {\n    this.effect.dirty = v;\n  }\n  // #endregion\n}\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = !!(process.env.NODE_ENV !== \"production\") ? () => {\n      warn(\"Write operation failed: computed value is readonly\");\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n  if (!!(process.env.NODE_ENV !== \"production\") && debugOptions && !isSSR) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n  return cRef;\n}\n\nfunction trackRefValue(ref2) {\n  var _a;\n  if (shouldTrack && activeEffect) {\n    ref2 = toRaw(ref2);\n    trackEffect(\n      activeEffect,\n      (_a = ref2.dep) != null ? _a : ref2.dep = createDep(\n        () => ref2.dep = void 0,\n        ref2 instanceof ComputedRefImpl ? ref2 : void 0\n      ),\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target: ref2,\n        type: \"get\",\n        key: \"value\"\n      } : void 0\n    );\n  }\n}\nfunction triggerRefValue(ref2, dirtyLevel = 4, newVal) {\n  ref2 = toRaw(ref2);\n  const dep = ref2.dep;\n  if (dep) {\n    triggerEffects(\n      dep,\n      dirtyLevel,\n      !!(process.env.NODE_ENV !== \"production\") ? {\n        target: ref2,\n        type: \"set\",\n        key: \"value\",\n        newValue: newVal\n      } : void 0\n    );\n  }\n}\nfunction isRef(r) {\n  return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n  return createRef(value, false);\n}\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n  return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n  constructor(value, __v_isShallow) {\n    this.__v_isShallow = __v_isShallow;\n    this.dep = void 0;\n    this.__v_isRef = true;\n    this._rawValue = __v_isShallow ? value : toRaw(value);\n    this._value = __v_isShallow ? value : toReactive(value);\n  }\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n  set value(newVal) {\n    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n    newVal = useDirectValue ? newVal : toRaw(newVal);\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = useDirectValue ? newVal : toReactive(newVal);\n      triggerRefValue(this, 4, newVal);\n    }\n  }\n}\nfunction triggerRef(ref2) {\n  triggerRefValue(ref2, 4, !!(process.env.NODE_ENV !== \"production\") ? ref2.value : void 0);\n}\nfunction unref(ref2) {\n  return isRef(ref2) ? ref2.value : ref2;\n}\nfunction toValue(source) {\n  return isFunction(source) ? source() : unref(source);\n}\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = void 0;\n    this.__v_isRef = true;\n    const { get, set } = factory(\n      () => trackRefValue(this),\n      () => triggerRefValue(this)\n    );\n    this._get = get;\n    this._set = set;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(newVal) {\n    this._set(newVal);\n  }\n}\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n  if (!!(process.env.NODE_ENV !== \"production\") && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n  const ret = isArray(object) ? new Array(object.length) : {};\n  for (const key in object) {\n    ret[key] = propertyToRef(object, key);\n  }\n  return ret;\n}\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n  get value() {\n    const val = this._object[this._key];\n    return val === void 0 ? this._defaultValue : val;\n  }\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n  get dep() {\n    return getDepFromReactive(toRaw(this._object), this._key);\n  }\n}\nclass GetterRefImpl {\n  constructor(_getter) {\n    this._getter = _getter;\n    this.__v_isRef = true;\n    this.__v_isReadonly = true;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction toRef(source, key, defaultValue) {\n  if (isRef(source)) {\n    return source;\n  } else if (isFunction(source)) {\n    return new GetterRefImpl(source);\n  } else if (isObject(source) && arguments.length > 1) {\n    return propertyToRef(source, key, defaultValue);\n  } else {\n    return ref(source);\n  }\n}\nfunction propertyToRef(source, key, defaultValue) {\n  const val = source[key];\n  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);\n}\n\nconst deferredComputed = computed;\n\nconst TrackOpTypes = {\n  \"GET\": \"get\",\n  \"HAS\": \"has\",\n  \"ITERATE\": \"iterate\"\n};\nconst TriggerOpTypes = {\n  \"SET\": \"set\",\n  \"ADD\": \"add\",\n  \"DELETE\": \"delete\",\n  \"CLEAR\": \"clear\"\n};\nconst ReactiveFlags = {\n  \"SKIP\": \"__v_skip\",\n  \"IS_REACTIVE\": \"__v_isReactive\",\n  \"IS_READONLY\": \"__v_isReadonly\",\n  \"IS_SHALLOW\": \"__v_isShallow\",\n  \"RAW\": \"__v_raw\"\n};\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, ReactiveFlags, TrackOpTypes, TriggerOpTypes, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseScheduling, pauseTracking, proxyRefs, reactive, readonly, ref, resetScheduling, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, toValue, track, trigger, triggerRef, unref };\n","import {ComponentUtil} from 'ag-grid-community';\n\nexport const kebabProperty = (property: string) => {\n    return property.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\n};\n\nexport const kebabNameToAttrEventName = (kebabName: string) => {\n    // grid-ready for example would become onGrid-ready in Vue\n    return `on${kebabName.charAt(0).toUpperCase()}${kebabName.substring(1, kebabName.length)}`\n};\n\nexport interface Properties {\n    [propertyName: string]: any;\n}\n\nexport const getAgGridProperties = (): [Properties, Properties, Properties] => {\n    const props: Properties = {};\n\n    // for example, 'grid-ready' would become 'onGrid-ready': undefined\n    // without this emitting events results in a warning\n    // and adding 'grid-ready' (and variations of this to the emits option in AgGridVue doesn't help either)\n    const eventNameAsProps = ComponentUtil.PUBLIC_EVENTS.map((eventName: string) => kebabNameToAttrEventName(kebabProperty(eventName)));\n    eventNameAsProps.forEach((eventName: string) => props[eventName] = undefined)\n\n    const computed: Properties = {\n        props() {\n            const options: { [key: string]: any } = {};\n            ComponentUtil.ALL_PROPERTIES.forEach((propertyName: string) => {\n                if (this[propertyName] === ComponentUtil.VUE_OMITTED_PROPERTY) { return; }\n                if (propertyName in this || propertyName in this.gridOptions) {\n                    options[propertyName] = this[propertyName] ?? this.gridOptions[propertyName];\n                }\n            });\n            return options;\n        },\n    };\n    const watch: Properties = {\n        modelValue: {\n            handler(currentValue: any, previousValue: any) {\n                if (!this.gridCreated || !this.api) { return; }\n                \n                /*\n                 * Prevents an infinite loop when using v-model for the rowData\n                 */\n                if (currentValue === previousValue) { return; }\n                if (currentValue && previousValue) {\n                    if (currentValue.length === previousValue.length) {\n                        if (currentValue.every((item: any, index: number) => item === previousValue[index])) {\n                            return;\n                        }\n                    }\n                }\n\n                ComponentUtil.processOnChange({ rowData: currentValue }, this.api);\n            },\n            deep: true\n        },\n        props: {\n            handler(currentValue: any, previousValue: any) {\n                if (!this.gridCreated || !this.api) { return; }\n                const changes: any = {};\n                Object.entries(currentValue).forEach(([key, value]) => {\n                    if (previousValue[key] === value) return;\n                    changes[key] = value;\n                });\n                ComponentUtil.processOnChange(changes, this.api);\n            },\n            deep: true,\n        },\n    };\n    ComponentUtil.ALL_PROPERTIES\n        .filter((propertyName: string) => propertyName != 'gridOptions') // dealt with in AgGridVue itself\n        .forEach((propertyName: string) => {\n            props[propertyName] = {\n                default: ComponentUtil.VUE_OMITTED_PROPERTY,\n            };\n        });\n\n    return [props, computed, watch];\n};\n\n","import {createVNode, defineComponent, render} from 'vue';\n\nexport class VueComponentFactory {\n\n    private static getComponentDefinition(component: any, parent: any) {\n        let componentDefinition: any;\n\n        // when referencing components by name - ie: cellRenderer: 'MyComponent'\n        if (typeof component === 'string') {\n            // look up the definition in Vue\n            componentDefinition = this.searchForComponentInstance(parent, component);\n        } else {\n            componentDefinition = {extends: defineComponent({...component})}\n        }\n        if (!componentDefinition) {\n            console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);\n        }\n\n        if (componentDefinition.extends) {\n            if (componentDefinition.extends.setup) {\n                componentDefinition.setup = componentDefinition.extends.setup;\n            }\n\n            componentDefinition.extends.props = this.addParamsToProps(componentDefinition.extends.props)\n        } else {\n            componentDefinition.props = this.addParamsToProps(componentDefinition.props)\n        }\n\n        return componentDefinition;\n    }\n\n    private static addParamsToProps(props: any) {\n        if (!props || (Array.isArray(props) && props.indexOf('params') === -1)) {\n            props = ['params', ...(props ? props : [])];\n        } else if (typeof props === 'object' && !props.params) {\n            /* tslint:disable:no-string-literal */\n            props['params'] = {\n                type: Object\n            };\n        }\n\n        return props;\n    }\n\n    public static createAndMountComponent(component: any, params: any, parent: any, provides: any) {\n        const componentDefinition = VueComponentFactory.getComponentDefinition(component, parent);\n        if (!componentDefinition) {\n            return;\n        }\n\n        const {vNode, destroy, el} = this.mount(componentDefinition, {params: Object.freeze(params)}, parent, provides || {})\n\n        // note that the component creation is synchronous so that componentInstance is set by this point\n        return {\n            componentInstance: vNode.component.proxy,\n            element: el,\n            destroy,\n        };\n    }\n\n    public static mount(component: any, props: any, parent: any, provides: any) {\n        let vNode: any = createVNode(component, props)\n\n        vNode.appContext = parent.$.appContext;\n        vNode.appContext.provides = {...provides, ...(vNode.appContext.provides ? vNode.appContext.provides : {}), ...(parent.$parent.$options.provide ? parent.$parent.$options.provide : {})};\n\n        let el: any = document.createElement('div')\n        render(vNode, el)\n\n        const destroy = () => {\n            if (el) {\n                render(null, el)\n            }\n\n            el = null;\n            vNode = null;\n        }\n\n        return {vNode, destroy, el}\n    }\n\n    public static searchForComponentInstance(\n        parent: any,\n        component: any,\n        maxDepth = 10,\n        suppressError = false\n    ) {\n        let componentInstance: any = null;\n\n        let currentParent = parent.$parent;\n        let depth = 0;\n        while (!componentInstance &&\n        currentParent &&\n        currentParent.$options &&\n        (++depth < maxDepth)) {\n            const currentParentAsThis = currentParent as any;\n            if (currentParentAsThis.$options && currentParentAsThis.$options.components && currentParentAsThis.$options.components![component as any]) {\n                componentInstance = currentParentAsThis.$options.components![component as any];\n            } else if (currentParentAsThis[component]) {\n                componentInstance = currentParentAsThis[component];\n            }\n            // componentInstance =  : null;\n            currentParent = currentParent.$parent;\n        }\n\n        // then search in globally registered components of app\n        if (!componentInstance) {\n            const components = parent.$.appContext.components\n            if (components && components[component]) {\n                componentInstance = components[component];\n            }\n        }\n\n        if (!componentInstance && !suppressError) {\n            console.error(`Could not find component with name of ${component}. Is it in Vue.components?`);\n            return null;\n        }\n        return componentInstance;\n    }\n}\n","import {BaseComponentWrapper, WrappableInterface} from 'ag-grid-community';\nimport {VueComponentFactory} from './VueComponentFactory';\n\ninterface VueWrappableInterface extends WrappableInterface {\n    overrideProcessing(methodName: string): boolean;\n\n    processMethod(methodName: string, args: IArguments): any;\n}\n\nexport class VueFrameworkComponentWrapper extends BaseComponentWrapper<WrappableInterface> {\n    private parent: any | null;\n\n    private static provides: any;\n\n    constructor(parent: any, provides?: any) {\n        super();\n\n        this.parent = parent;\n\n        // when using master detail things provides to the master (like urlql) will not be available to the child components\n        // we capture the parent provides here (the first one will be the parent) - and re-use this when creating child components in VueComponentFactory\n        if (!VueFrameworkComponentWrapper.provides) {\n            VueFrameworkComponentWrapper.provides = provides;\n        }\n    }\n\n    public createWrapper(component: any): WrappableInterface {\n        const that = this;\n\n        class DynamicComponent extends VueComponent<any, any> implements WrappableInterface {\n            public init(params: any): void {\n                super.init(params);\n            }\n\n            public hasMethod(name: string): boolean {\n                const componentInstance = wrapper.getFrameworkComponentInstance()\n                if (!componentInstance[name]) {\n                    return componentInstance.$.setupState[name] != null\n                } else {\n                    return true\n                }\n            }\n\n            public callMethod(name: string, args: IArguments): any {\n                const componentInstance = this.getFrameworkComponentInstance();\n                const frameworkComponentInstance = wrapper.getFrameworkComponentInstance();\n                if (frameworkComponentInstance[name]) {\n                    return frameworkComponentInstance[name].apply(componentInstance, args);\n                } else {\n                    return frameworkComponentInstance.$.setupState[name]?.apply(componentInstance, args);\n                }\n            }\n\n            public addMethod(name: string, callback: () => any): void {\n                (wrapper as any)[name] = callback;\n            }\n\n            public overrideProcessing(methodName: string): boolean {\n                return that.parent!.autoParamsRefresh && methodName === 'refresh';\n            }\n\n            public processMethod(methodName: string, args: IArguments): any {\n                if (methodName === 'refresh') {\n                    this.getFrameworkComponentInstance().params = args[0];\n                }\n\n                if (this.hasMethod(methodName)) {\n                    return this.callMethod(methodName, args);\n                }\n\n                return methodName === 'refresh';\n            }\n\n            protected createComponent(params: any): any {\n                return that.createComponent(component, params);\n            }\n        }\n\n        const wrapper = new DynamicComponent();\n        return wrapper;\n    }\n\n    public createComponent<T>(component: any, params: any): any {\n        return VueComponentFactory.createAndMountComponent(component, params, this.parent!, VueFrameworkComponentWrapper.provides!);\n    }\n\n    protected createMethodProxy(wrapper: VueWrappableInterface, methodName: string, mandatory: boolean): () => any {\n        return function () {\n            if (wrapper.overrideProcessing(methodName)) {\n                return wrapper.processMethod(methodName, arguments);\n            }\n\n            if (wrapper.hasMethod(methodName)) {\n                return wrapper.callMethod(methodName, arguments);\n            }\n\n            if (mandatory) {\n                console.warn('AG Grid: Framework component is missing the method ' + methodName + '()');\n            }\n            return null;\n        };\n    }\n\n    protected destroy() {\n        this.parent = null;\n    }\n}\n\nabstract class VueComponent<P, T> {\n    private componentInstance: any;\n    private element!: HTMLElement;\n    private unmount: any;\n\n    public getGui(): HTMLElement {\n        return this.element;\n    }\n\n    public destroy(): void {\n        if (this.getFrameworkComponentInstance() && typeof this.getFrameworkComponentInstance().destroy === 'function') {\n            this.getFrameworkComponentInstance().destroy();\n        }\n        this.unmount();\n    }\n\n    public getFrameworkComponentInstance(): any {\n        return this.componentInstance;\n    }\n\n    protected init(params: P): void {\n        const {componentInstance, element, destroy: unmount} = this.createComponent(params);\n\n        this.componentInstance = componentInstance;\n        this.unmount = unmount;\n\n        // the element is the parent div we're forced to created when dynamically creating vnodes\n        // the first child is the user supplied component\n        this.element = element.firstElementChild ?? element;\n    }\n\n    protected abstract createComponent(params: P): any;\n}\n\n","import {VanillaFrameworkOverrides} from 'ag-grid-community';\nimport {VueComponentFactory} from './VueComponentFactory';\n\nexport class VueFrameworkOverrides extends VanillaFrameworkOverrides {\n    private readonly parent: any;\n\n    constructor(parent: any) {\n        super('vue');\n\n        this.parent = parent;\n    }\n\n    /*\n     * vue components are specified in the \"components\" part of the vue component - as such we need a way to determine\n     * if a given component is within that context - this method provides this\n     * Note: This is only really used/necessary with cellRendererSelectors\n     */\n    public frameworkComponent(name: string, components?: any): any {\n        let result = !!VueComponentFactory.searchForComponentInstance(this.parent, name, 10, true) ? name : null;\n        if (!result && components && components[name]) {\n            const indirectName = components[name];\n            result = !!VueComponentFactory.searchForComponentInstance(this.parent, indirectName, 10, true) ? indirectName : null;\n        }\n        return result;\n    }\n\n    public isFrameworkComponent(comp: any): boolean {\n        return typeof comp === 'object';\n    }\n}\n","import { defineComponent, getCurrentInstance, h, PropType } from 'vue';\nimport { markRaw, toRaw } from '@vue/reactivity';\nimport { ComponentUtil, createGrid, Events, GridApi, GridOptions, IRowNode, Module } from 'ag-grid-community';\n\nimport { getAgGridProperties, Properties } from './Utils';\nimport { VueFrameworkComponentWrapper } from './VueFrameworkComponentWrapper';\nimport { VueFrameworkOverrides } from './VueFrameworkOverrides';\n\nconst ROW_DATA_EVENTS: Set<string> = new Set(['rowDataUpdated', 'cellValueChanged', 'rowValueChanged']);\nconst ALWAYS_SYNC_GLOBAL_EVENTS: Set<string> = new Set([Events.EVENT_GRID_PRE_DESTROYED]);\nconst DATA_MODEL_ATTR_NAME = 'onUpdate:modelValue'; // emit name would be update:ModelValue\nconst DATA_MODEL_EMIT_NAME = 'update:modelValue';\n\nconst [props, computed, watch] = getAgGridProperties();\n\nexport const AgGridVue = defineComponent({\n    render() {\n        return h('div')\n    },\n    props: {\n        gridOptions: {\n            type: Object as PropType<GridOptions>,\n            default: () => ({} as GridOptions),\n        },\n        autoParamsRefresh: {\n            type: Boolean,\n            default: () => false,\n        },\n        componentDependencies: {\n            type: Array as PropType<String[]>,\n            default: () => [],\n        },\n        plugins: [],\n        modules: {\n            type: Array as PropType<Module[]>,\n            default: () => [],\n        },\n        modelValue: {\n            type: Array,\n            default: undefined,\n            required: false\n        },\n        ...props\n    },\n    data() : {\n        api: GridApi | undefined,\n        gridCreated: boolean,\n        isDestroyed: boolean,\n        gridReadyFired: boolean,\n        emitRowModel?: (() => void | null),\n    } {\n        return {\n            api: undefined,\n            gridCreated: false,\n            isDestroyed: false,\n            gridReadyFired: false,\n            emitRowModel: undefined\n        }\n    },\n    computed,\n    watch,\n    methods: {\n        globalEventListenerFactory(restrictToSyncOnly?: boolean) {\n            return (eventType: string, event: any) => {\n                if (this.isDestroyed) {\n                    return;\n                }\n\n                if (eventType === 'gridReady') {\n                    this.gridReadyFired = true;\n                }\n\n                const alwaysSync = ALWAYS_SYNC_GLOBAL_EVENTS.has(eventType);\n                if ((alwaysSync && !restrictToSyncOnly) || (!alwaysSync && restrictToSyncOnly)) {\n                    return;\n                }\n\n                this.updateModelIfUsed(eventType);\n            }\n        },\n        processChanges(propertyName: string, currentValue: any, previousValue: any) {\n            if (this.gridCreated) {\n                if (this.skipChange(propertyName, currentValue, previousValue)) {\n                    return;\n                }\n\n                const options: Properties = {\n                    [propertyName]: propertyName === 'rowData' ? (\n                            Object.isFrozen(currentValue) ? currentValue : markRaw(toRaw(currentValue))\n                        ) : currentValue,\n                };\n                // decouple the row data - if we don't when the grid changes row data directly that'll trigger this component to react to rowData changes,\n                // which can reset grid state (ie row selection)\n                ComponentUtil.processOnChange(options, this.api as any);\n            }\n        },\n        checkForBindingConflicts() {\n            const thisAsAny = (this as any);\n            if ((thisAsAny.rowData || this.gridOptions.rowData) &&\n                thisAsAny.modelValue) {\n                console.warn('AG Grid: Using both rowData and v-model. rowData will be ignored.');\n            }\n        },\n        getRowData(): any[] {\n            const rowData: any[] = [];\n            this.api?.forEachNode((rowNode: IRowNode) => {\n                rowData.push(rowNode.data);\n            });\n            return rowData;\n        },\n        updateModelIfUsed(eventType: string) {\n            if (this.gridReadyFired &&\n                this.$attrs[DATA_MODEL_ATTR_NAME] &&\n                ROW_DATA_EVENTS.has(eventType)) {\n\n                if (this.emitRowModel) {\n                    this.emitRowModel();\n                }\n            }\n        },\n        getRowDataBasedOnBindings() {\n            const thisAsAny = (this as any);\n\n            const rowData = thisAsAny.modelValue\n            return rowData ? rowData :\n                thisAsAny.rowData ? thisAsAny.rowData : thisAsAny.gridOptions.rowData;\n        },\n        getProvides() {\n            let instance = getCurrentInstance() as any;\n            let provides = {};\n\n            while (instance) {\n                if (instance && instance.provides) {\n                    provides = {...provides, ...instance.provides}\n                }\n\n                instance = instance.parent;\n            }\n\n            return provides;\n        },\n        /*\n        * Prevents an infinite loop when using v-model for the rowData\n        */\n        skipChange(propertyName: string, currentValue: any, previousValue: any) {\n            if (this.gridReadyFired &&\n                propertyName === 'rowData' &&\n                this.$attrs[DATA_MODEL_ATTR_NAME]) {\n                if (currentValue === previousValue) {\n                    return true;\n                }\n\n                if (currentValue && previousValue) {\n                    const currentRowData = currentValue as any[];\n                    const previousRowData = previousValue as any[];\n                    if (currentRowData.length === previousRowData.length) {\n                        for (let i = 0; i < currentRowData.length; i++) {\n                            if (currentRowData[i] !== previousRowData[i]) {\n                                return false;\n                            }\n                        }\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        },\n        debounce(func: () => void, delay: number) {\n            let timeout: number;\n            return () => {\n                const later = function () {\n                    func();\n                };\n                window.clearTimeout(timeout);\n                timeout = window.setTimeout(later, delay);\n            };\n        }\n    },\n    mounted() {\n        // we debounce the model update to prevent a flood of updates in the event there are many individual\n        // cell/row updates\n        this.emitRowModel = this.debounce(() => {\n            this.$emit(DATA_MODEL_EMIT_NAME, Object.freeze(this.getRowData()));\n        }, 20);\n\n\n        const provides = this.getProvides();\n        const frameworkComponentWrapper = new VueFrameworkComponentWrapper(this, provides);\n\n        // the gridOptions we pass to the grid don't need to be reactive (and shouldn't be - it'll cause issues\n        // with mergeDeep for example\n        const gridOptions = markRaw(ComponentUtil.combineAttributesAndGridOptions(toRaw(this.gridOptions), this));\n\n        this.checkForBindingConflicts();\n\n        const rowData = this.getRowDataBasedOnBindings();\n        if (rowData !== ComponentUtil.VUE_OMITTED_PROPERTY) {\n            gridOptions.rowData = rowData ? (Object.isFrozen(rowData) ? rowData : markRaw(toRaw(rowData))) : rowData;\n        }\n\n        const gridParams = {\n            globalEventListener: this.globalEventListenerFactory().bind(this),\n            globalSyncEventListener: this.globalEventListenerFactory(true).bind(this),\n            frameworkOverrides: new VueFrameworkOverrides(this),\n            providedBeanInstances: {\n                frameworkComponentWrapper,\n            },\n            modules: this.modules,\n        };\n\n        this.api = createGrid(this.$el as HTMLElement, gridOptions, gridParams);\n        this.gridCreated = true;\n    },\n    unmounted() {\n        if (this.gridCreated) {\n            this.api?.destroy();\n            this.isDestroyed = true;\n        }\n    }\n});\n"],"sourceRoot":""}